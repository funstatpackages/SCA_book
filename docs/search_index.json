[
["index.html", "Statistical Computing Using R Chapter 1 Preface 1.1 What you will learn 1.2 Acknowledgements 1.3 About the Author", " Statistical Computing Using R Lily Wang 2021-01-10 Chapter 1 Preface 1.1 What you will learn This book introduces modern statistical computing for students with some experience with computer programming. It covers both programming concepts and statistical computing concepts. Programming concepts will include data manipulations, data structures, flow control, functions and variable scope, regular expressions, and matrix manipulations. You’ll learn how to get your data into R, get it into the most useful structure, transform it, visualize it and model it. You’ll learn how to use the grammar of graphics, literate programming, and reproducible research to save time. You’ll also learn how to manage cognitive resources to facilitate discoveries when wrangling, visualizing and exploring data. Statistical computing topics will focus on the tools that are useful for tackling modern data analysis problems and using statistical methods to extract meaning from data. 1.2 Acknowledgements I am very appreciative of all the contributors to this immense open source project of R and R-Studio. I couldn’t have made this book without your contributions and the packages that you have developed. A special thanks go to Dr. Guannan Wang and Miss Zhiling Gu for their help with the book. I would also like to thank Yihui Xie (Xie 2020) for his R Markdown package, which simplifies the writing of this book by having all content written in R Markdown. 1.3 About the Author Dr. Lily Wang is a tenured Professor of Statistics at Iowa State University. She received her Ph.D. in Statistics from Michigan State University in 2007. Prior to joining Iowa State in 2014, she was a tenure-track Assistant/tenured Associate Professor in the Department of Statistics at the University of Georgia 2007-2013/2013-2014. Her primary areas of research include developing cutting-edge statistical non/semi-parametric methods, statistical learning of large datasets with complex features, methodologies for functional data, imaging data, and spatiotemporal data, survey sampling, and the application of statistics to problems in economics, engineering, neuroimaging, epidemiology, environmental studies, and biomedical science. References "],
["intro.html", "Chapter 2 R Introduction and Preliminaries 2.1 The R Environment and Language 2.2 R and Statistics 2.3 Installing R and RStudio 2.4 Starting R 2.5 Exercises", " Chapter 2 R Introduction and Preliminaries 2.1 The R Environment and Language R is an integrated suite of software facilities for data manipulation, calculation and graphical display. The benefits of R for an introductory student R is free. R is open-source and runs on UNIX, Windows and Macintosh. R has an excellent built-in help system. R has excellent graphing capabilities. Students can easily migrate to the commercially supported S-Plus program if commercial software is desired. R’s language has a powerful, easy to learn syntax with many built-in statistical functions. The language is easy to extend with user-written functions. R is a computer programming language. For programmers it will feel more familiar than others and for new computer users, the next leap to programming will not be so large. What is R lacking compared to other software solutions? There is no commercial support. (Although one can argue the international mailing list is even better) The command language is a programming language so students must learn to appreciate syntax issues etc. R can be regarded as an implementation of the S language which was developed at Bell Laboratories by Rick Becker, John Chambers and Allan Wilks, and also forms the basis of the S-Plus systems. R and SAS Comparison R is in many ways comparable with SAS. The software is predominately syntax driven and relies on its user to known the R language (which in many ways resembles the S and UNIX programming languages). R is comparable in structure and conceptual arrangement to other syntax based software packages. Similarities and dissimilarities with other software packages will be pointed out to facilitate an easier transition into R. Technically R is an expression language with a very simple syntax. Unlike SAS, it is case sensitive, so A and a are different symbols and would refer to different variables. Commands are separated either by a semi-colon (“;”), or by a newline. Elementary commands can be grouped together into one compound expression by braces (“{” and “}”). Comments can be put almost anywhere, starting with a hash-mark (“#”), everything to the end of the line is a comment. If a command is not complete at the end of a line, R will give a different prompt, by default “+” on second and subsequent lines and continue to read input until the command is syntactically complete. 2.2 R and Statistics Many people use R as a statistics system. We prefer to think of it as an environment within which many classical and modern statistical techniques have been implemented. A few of these are built into the base R environment, but many are supplied as packages. There are about 25 packages supplied with R (called “standard” and “recommended” packages) and many more are available through the CRAN family of Internet sites (via http://CRAN.R-project.org) and elsewhere. More details on packages are given later. Most classical statistics and much of the latest methodology is available for use with R, but users may need to be prepared to do a little work to find it. 2.3 Installing R and RStudio 2.3.1 Obtaining R and installation Obtaining R Sources, binaries, and documentation for R can be obtained via CRAN, the “Comprehensive R Archive Network” whose current members are listed at http://cran.r-project.org/mirrors.html. Installing R under Windows (via http://CRAN.R-project.org) The bin/windows directory of a CRAN site contains binaries for a base distribution and many add-on packages from CRAN to run on Windows 2000 or later on ix86 CPUs (including AMD64/EM64T chips and Windows x64). Your file system must allow long file names (as is likely except perhaps for some network-mounted systems). Installation is straightforward. Just double-click on the icon and follow the instructions. You can uninstall R from the Control Panel or the (optional) R program group on the Start Menu. Installing R under Macintosh (via http://CRAN.R-project.org) Visit the Comprehensive R Archive Network (CRAN) and select a mirror site near you; a list of CRAN mirrors appears at the upper left of the CRAN home page. Click on the link Download R for Mac OS X, which appears near the top of the page; then click on R-X.X.X.pkg (or whatever is the current version of R), which assumes that you are using Mac OS X 10.9 (Mavericks) or higher. You will also find an older version of R if you have an older version of Mac OS X (10.6, Snow Leopard, or higher). Once it is downloaded, double-click on the R installer. You may take all of the defaults. 2.3.2 Installing RStudio After you install R, you can install R Studio. Download and install RStudio at https://www.rstudio.com/products/rstudio/download/. Scroll down to “Installers for Supported Platforms” near the bottom of the page. Click on the download link corresponding to your computer’s operating system. 2.4 Starting R RStudio is most easily used in an interactive manner. After installing R and RStudio on your computer, you’ll have two new programs (also called applications) you can open. We’ll always work in RStudio and not in the R application. Figure 2.1 below shows what icon you should be clicking on your computer. Figure 2.1: Icons of R versus RStudio on your computer. After you open RStudio, you should see something similar to Figure 2.2 below. Figure 2.2: RStudio interface to R. Note the three panels divide the screen: the console panel, the files panel, and the environment panel. Throughout this chapter, you’ll come to learn what purpose each of these panels serves. Console: This is the place to write any code that needs to be run. Environment: This lists what variables and objects (referred to in R) are currently available in your working environment. Within the environment window, there are also other tabs such as ‘history’, which shows a history of all code typed in the past. It also has a tab called ‘connection,’ which is meant for connecting to specific databases. This tab is not useful to a beginner. Viewer: For lack of a better way to refer to the third pane, it is referred to here as ‘viewer.’ However, the third pane has several tabs nested within it. The “files” tab shows all the files and folders in your current directory, which the program points to right next to the home icon below the header for the pane. The “plots” tab shows and allows for the saving of any plot output. The “packages” tab shows all the packages that are currently installed. As you start using R-Studio, you will find the need to install many packages and R-Studio makes it easy to do so. 2.4.1 Description of three panels in user interface R Console window The R Environment contains the software’s libraries with all the available datasets, expansion packages and macros. As compared to SAS, the Log and Editor windows are consolidated into a single interface, the “R Console”. Figure 2.3: The R Console. Note: The &gt; is called the prompt. In what follows below it is not typed, but is used to indicate where you are to type if you follow the examples. The Console can be used like a calculator. Below are some examples: 2 + 2 ## [1] 4 (2 - 3) / 6 ## [1] -0.1666667 2 ^ 2 ## [1] 4 sin(pi / 2) ## [1] 1 log(1) ## [1] 0 Results from these calculations can be stored in an object. The &lt;- is used to make the assignment and is read as “gets”. save &lt;- 2 + 2 save The objects are stored in R’s database. When you close R, you will be asked if you would like to save or delete them. This is kind of like the SAS WORK library, but R gives you a choice to save them. To see a listing of the objects, you can do either of the following: ls() objects() To delete an object, use rm() and insert the object name in the parentheses. rm(x, y, z, ink, junk, temp, foo, bar) All objects created during an R session can be stored permanently in a file for use in future R sessions. At the end of each R session, you are given the opportunity to save all the currently available objects. If you indicate that you want to do this, the objects are written to a file called .RData in the current directory (“Save Workspace”), and the command lines used in the session are saved to a file called .Rhistory (“Save History”). R Editor window – type your long R program here Often, you will have a long list of commands that you would like to execute all at once, i.e., a program. Instead of typing all of the code line by line at the R Console, you could type it in the R Script Window. Select File -&gt; New File -&gt; R script to create a new program. Below is what the editor looks like. To run the current line of the code (where the cursor is positioned) or some code highlighted, click “Run”. To save your code as a program outside of R, select File -&gt; Save and make sure to use an .R extension on the file name. Error messages R will provide intuitive error messages regarding the submitted syntax. Unlike in SAS these comments are printed right in the console. 2 + 2 2 + 2 + (3xz 2 + (3 * z) R will provide intuitive error messages regarding the submitted syntax. Unlike in SAS these comments are printed right in the console. 2.4.2 R help To see a listing of all R functions which are “built in”, open the Help by selecting Help -&gt; R Help from the main menu bar. Under Reference, select the link called Packages. All built-in R functions are stored in a package. We have been using functions from the base and stats package. By selecting stats, you can scroll down to find help on the pnorm() function. Note the full syntax for pnorm() is pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE) The q value corresponds to the 1.96 can be found by pnorm(1.96) ## [1] 0.9750021 pnorm(q = 1.96) ## [1] 0.9750021 pnorm(q = 1.96, mean = 0, sd = 1) ## [1] 0.9750021 These produce the same results. The other entries in the function have default values set. For example, R assumes you want to work with the standard normal distribution by assigning mean=0 and sd=1 (standard deviation). If you know the exact name of the function, simply type help(function name) at the R Console command prompt to bring up its help in a window inside of R. For example, help(pnorm) brings up Figure 2.4 Figure 2.4: The R help for the R function pnorm(). An alternative is ?pnorm For a feature specified by special characters, the argument must be enclosed in double or single quotes, making it a “character string”: This is also necessary for a few words with syntactic meaning including if and for functions. help(&quot;pnorm&quot;) If you need to use a function but don’t know its exact name or are not sure of its existence. There is a very useful function called apropos(‘argument‘) that lists all functions that contain your argument as part of their names. Note that your argument must be put within either single or double quotation marks. For example, here is what I got when I looked for similar functions containing the string table: apropos(&#39;table&#39;) ## [1] &quot;.S3_methods_table&quot; &quot;[.table&quot; ## [3] &quot;aperm.table&quot; &quot;as.data.frame.table&quot; ## [5] &quot;as.relistable&quot; &quot;as.table&quot; ## [7] &quot;as.table.default&quot; &quot;ftable&quot; ## [9] &quot;is.relistable&quot; &quot;is.table&quot; ## [11] &quot;margin.table&quot; &quot;model.tables&quot; ## [13] &quot;pairwise.table&quot; &quot;print.summary.table&quot; ## [15] &quot;print.table&quot; &quot;prop.table&quot; ## [17] &quot;r2dtable&quot; &quot;read.ftable&quot; ## [19] &quot;read.table&quot; &quot;summary.table&quot; ## [21] &quot;table&quot; &quot;write.ftable&quot; ## [23] &quot;write.table&quot; &quot;xyTable&quot; Note that the argument is a string, so it does not need to be an actual word or name of a function. For example, apropos('tabl') will return the same results. Try it! There may be other times when you want to learn about all functions involving a certain term, but searching for R-related pages on that term returns too many irrelevant results. This term may not even be an R function or command, making the Google search all the more difficult, even with good searching techniques. In these situations, use the help.search(‘argument‘) function. (Again, you need to put your arguments around single or double quotation marks.) This will return all functions with your argument in the help page title or as an alias. For example, I wanted to know about using PDF files in R. I ran help.search(‘pdf’) in R and got the following results. help.search(&quot;pdf&quot;) 2.4.3 Packages This is a very important topic in R. In SAS and SPSS installations, you usually have everything you have paid for installed at once. R is much more modular. The main installation will install R and a popular set of add‐ons called libraries. Hundreds of other libraries are available to install separately from the Comprehensive R Archive Network, (CRAN). Right under the “viewer” tab, the icon for “setting” allows for changing the working directory or copying and moving files. The tab for “packages,” shows all the packages that are installed and available. Clicking on the checkbox next to the name of the package loads the package for use using the following command, which will appear in the console pane of the interface. Library(Package name) Clicking on the name of the package (under the package tab on the lower right pane) itself brings up the description of what the package does. This is one of the benefits of using R-Studio as opposed to R, which makes it easy to look up all the packages available and what each does. Although the description and examples for packages are sometimes not explicit enough, it is nevertheless a useful starting point for many tasks. The viewer pane tab also makes it easy to install and update packages right from the lower right panel of the user interface. If you want to use functions in other packages, you may need to install and then load the package into R. Packages if they have already been downloaded from a CRAN mirror site can be loaded using this procedure. If the package has not been downloaded, it can be installed using the Install package(Package name) option. Also, an installed package can be loaded by specifying library (name of package). For example, we will be using the ggplot2 package later for data visualization. While in the R console, select Tools -&gt; Install Packages from the main menu. A number of locations around the world will come up. Insert the ggplot2 package and select Install. The package will now be installed onto your computer. This only needs to be done once on your computer. To load the package into your current R session, type library(ggplot2) at the R Console prompt. This needs to be done only once in an R session. If you close R and reopen, you will need to use the library() function again. If the package contains example data sets, you can load them with the data command. Enter data() to see what is available and then data(mydata) to load one named, for example, mydata. Clicking on the link to the package name from within the “packages” tab in the viewer pane provides an overview of what the package does. Here it is useful to spend some time understanding how to use a package. Clicking on the link provides details on its documentation. Next to the package is the package title, which states, “Create Elegant Data Visualisations Using the Grammar of Graphics.” Thus, ggplot2 is a package that makes elegant data visualizations. Clicking on the package link provides an alphabetized list of all that the package does, such as a function called aes that helps construct aesthetic mappings. Another function called borders helps to create a layer of map borders. Clicking on the link aes provides an explanation for what the function does and the way (syntax) it is used. Understanding the structure of this description helps us understand how to use packages. The description of the function within the package has several parts to it as follows: Description: Aesthetic mappings describe how variables in the data are mapped to visual properties (aesthetics) of geoms. Aesthetic mappings can be set in ggplot() and in individual layers. Usage: The second aspect of the description of the function refers to its usages. Arguments: The third part of the structure of a function is referred to as arguments. This describes the objects or variables that this function will operate on. Example: Typically, any description of what a function does is accompanied by an example of how to use it. Thus, understanding how to install a package, the functions it is capable of, along with the examples its description provides makes R very versatile for the user. In the next chapter, we will learn how to use R and its basic functions. 2.4.4 Creating a project and setting working directory Before launching into creating a dataset, it is important to understand how R handles data from a filing and directory perspective. Before creating a dataset, R starts with the creation of a ‘new project.’ A project name is a name given to a folder that will hold everything associated with a specific project such as data, history of commands used, objects (In R, a variable and/or data are stored as “objects”), or variables are created. Along with creating a new project name, it is important to understand the concept of the working directory as R will look for variables and objects or any other files that are being called in the working directory. A simple way to check on the current working directory is to type the command getwd() into the command console. If it is not the intended directory you want to use, the simplest way to change it is by using the “viewer” pane and clicking on the tab that says ‘more.’ Ensuring that your working directory is where you want your files and objects created to be stored is important, especially to a beginner. You may now create a new project by opening R-Studio, clicking on the file, and then ‘new project.’ As shown in Figure 2.5 that opens asks if you would like to open the project in an existing directory, a new one, or simply version control. The existing directory is the directory that is currently the working directory. You may either choose an existing directory or a new one. However, if you choose a new one, you need to make sure that it is selected as the working directory as shown earlier. You may name your project as ‘Learning R.’ Figure 2.5: Interface for creating a project in R. Once the project is created, you will see a .proj file under the files section in the viewer pane, as shown in Figure 2.6. As the figure shows, a new project called ‘Learning R.rproj’ has been created in the directory ~/STAT 480/Learning R. Any work done will now be stored in this directory (by setting it as the working directory) and in this project as long as it is saved when you exit. Figure 2.6: Directory with new project. 2.5 Exercises Use R to do the following Assign the value of 39 to x. Assign the value of 22 to y. Make z the value of x - y. Display the value of z in the console You can use R for magic tricks: Pick any number. Double it, and then add 12 to the result. Divide by 2, and then subtract your original number. Did you end up with 6.0? Use R to calculate the following: \\(31 \\times (78-20)^2\\) \\(697/41\\) \\(\\sqrt{123}\\) Download a dataset from Principles of Econometrics and save it in your local folder. Install the package readxl and read in the excel dataset you saved. library(readxl) help(&quot;read_excel&quot;) "],
["simple-manipulations-numbers-and-vectors.html", "Chapter 3 Simple Manipulations — Numbers and Vectors 3.1 Vectors and Assignment 3.2 Vector Arithmetic 3.3 Generating Regular Sequences 3.4 Logical Vectors 3.5 Missing values 3.6 Character Vectors 3.7 Index Vectors 3.8 Exercises:", " Chapter 3 Simple Manipulations — Numbers and Vectors 3.1 Vectors and Assignment R operates on named data structures. The simplest such structure is the numeric vector, a single entity consisting of an ordered collection of numbers. To set up a vector named x, say, consisting of five numbers, namely 10.4, 5.6, 3.1, 6.4, and 21.7, use the R command: x &lt;- c(10.4, 5.6, 3.1, 6.4, 21.7) #set up a vector x ## [1] 10.4 5.6 3.1 6.4 21.7 This is an assignment statement using the function c(), which can take an arbitrary number of vector arguments and whose value is a vector got by concatenating its arguments end to end. A few remarks: We assigned the values to a variable called x. The assignment operator is a &lt;- , which consists of the two characters &lt; (“less than”) and - (“minus”) occurring strictly side-by-side, and it ‘points’ to the object receiving the value of the expression. In most contexts, the ‘=’ operator can be used as an alternative. Both will be used, although you should learn one and stick with it. The value of the x doesn’t automatically print out. It does when we type just the name though, as the last input line indicates. The value of x is prefaced with a funny looking [1]. This indicates that the value is a vector. More on that later. A number occurring by itself in an expression is taken as a vector of length one. Assignment can also be made using the function assign(). An equivalent way of making the same assignment as above is with: assign(&quot;x&quot;, c(10.4, 5.6, 3.1, 6.4, 21.7)) The usual operator, &lt;-, can be thought of as a syntactic short-cut to this. Assignments can also be made in the other direction, using the obvious change “-&gt;” in the assignment operator. So the same assignment could be made using c(10.4, 5.6, 3.1, 6.4, 21.7) -&gt; x x ## [1] 10.4 5.6 3.1 6.4 21.7 If an expression is used as a complete command, the value is printed and lost. So now if we were to use the command 1/x #reciprocal of x ## [1] 0.09615385 0.17857143 0.32258065 0.15625000 0.04608295 the reciprocals of the five values would be printed at the terminal (and the value of x, of course, unchanged), but 1/x will be lost in R. More example: The following assignment y &lt;- c(x, 0, x) y ## [1] 10.4 5.6 3.1 6.4 21.7 0.0 10.4 5.6 3.1 6.4 21.7 would create a vector y with 11 entries consisting of two copies of x with a zero in the middle place. 3.2 Vector Arithmetic Vectors can be used in arithmetic expressions, in which case the operations are performed element by element. x = c(1, 2, 3) y = c(4, 5, 6) v = 2 * x + y + 1 Note: Vectors occurring in the same expression need not all be of the same length. If they are not, the value of the expression is a vector with the same length as the longest vector which occurs in the expression. Shorter vectors in the expression are recycled as often as need be (perhaps fractionally) until they match the length of the longest vector. In particular, a constant is simply repeated. x1 = c(1, 2) y1 = c(3, 5, 6, 8) x1 + y1 ## [1] 4 7 7 10 Try this yourself. The elementary arithmetic operators are the usual +, -, *, / and ^ for raising to a power. In addition all of the common arithmetic functions are available. log, exp, sin, cos, tan, sqrt, and so on, all have their usual meaning. exp((x + y)^2) / sqrt((x * y)) length(x) is the number of elements in x, sum(x) gives the total of the elements in x. Quick guide to soome built-in statistical functions in R mean(x) # compute mean of variable x median(x) # compute median of variable x sd(x) # compute standard deviation of numbers in vector x scale(x) # compute z-scores of numbers in vector x quantile(x) # compute the quartiles or percentiles of vector x var(x) # computes variance of variable x cov(x,y) # computes variance of variables x and y cor(x,y) # computes correlation of variables x and y For example, x &lt;- c(0, 5, 9, 12, 35) length(x) ## [1] 5 sum(x) ## [1] 61 xm &lt;- mean(x) xsd &lt;- sqrt(var(x)) 3.3 Generating Regular Sequences R has many facilities for generating commonly used sequences of numbers. For example 1:30 is the vector c(1, 2, ..., 29, 30). The colon operator has a high priority within an expression, so, for example, 2*1:15 is really 2*(1:15), so we have the vector c(2, 4, ..., 28, 30). Put n &lt;- 10 and you can compare the sequences 1:n-1 and 1:(n-1). The construction 30:1 may be used to generate a sequence backward. The function seq() is a more general facility for generating sequences. It has five arguments, only some of which may be specified in any one call. The first two arguments, if given, specify the beginning and end of the sequence, and if these are the only two arguments given, the result is the same as the colon operator. That is, seq(2,10) is the same vector as 2:10. Parameters to seq(), and to many other R functions, can also be given in named form, in which case the order in which they appear is irrelevant. The first two parameters may be named from=value and to=value; thus seq(1,30), seq(from=1, to=30) and seq(to=30, from=1) are all the same as 1:30. The next two parameters to seq() may be named by=value and length=value, which specify a step size and a length for the sequence, respectively. If neither of these is given, the default by=1 is assumed. For example, seq(-5, 5, by = .2) -&gt; s3 s3 ## [1] -5.0 -4.8 -4.6 -4.4 -4.2 -4.0 -3.8 -3.6 -3.4 -3.2 -3.0 ## [12] -2.8 -2.6 -2.4 -2.2 -2.0 -1.8 -1.6 -1.4 -1.2 -1.0 -0.8 ## [23] -0.6 -0.4 -0.2 0.0 0.2 0.4 0.6 0.8 1.0 1.2 1.4 ## [34] 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 3.2 3.4 3.6 ## [45] 3.8 4.0 4.2 4.4 4.6 4.8 5.0 s4 &lt;- seq(length = 51, from = -5, by = .2) s4 ## [1] -5.0 -4.8 -4.6 -4.4 -4.2 -4.0 -3.8 -3.6 -3.4 -3.2 -3.0 ## [12] -2.8 -2.6 -2.4 -2.2 -2.0 -1.8 -1.6 -1.4 -1.2 -1.0 -0.8 ## [23] -0.6 -0.4 -0.2 0.0 0.2 0.4 0.6 0.8 1.0 1.2 1.4 ## [34] 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 3.2 3.4 3.6 ## [45] 3.8 4.0 4.2 4.4 4.6 4.8 5.0 The fifth parameter may be named along=vector, which, if used must be the only parameter, and creates a sequence 1, 2, ..., length(vector), or the empty sequence if the vector is empty (as it can be). A related function is rep(), which can be used for replicating an object in various complicated ways. The simplest form is options(width = 60) s5 &lt;- rep(x, times = 5) s5 ## [1] 0 5 9 12 35 0 5 9 12 35 0 5 9 12 35 0 5 9 ## [19] 12 35 0 5 9 12 35 which will put five copies of x end-to-end in s5. Another useful version is options(width = 60) s6 &lt;- rep(x, each = 5) s6 ## [1] 0 0 0 0 0 5 5 5 5 5 9 9 9 9 9 12 12 12 ## [19] 12 12 35 35 35 35 35 which repeats each element of x five times before moving on to the next. 3.4 Logical Vectors As well as numerical vectors, R allows manipulation of logical quantities. The elements of a logical vector can have the values TRUE, FALSE, and NA (for “not available”, see below). The first two are often abbreviated as T and F, respectively. Note, however, that T and F are just variables that are set to TRUE and FALSE by default, but are not reserved words and hence can be overwritten by the user. Therefore, you should always use TRUE and FALSE. Logical vectors are generated by conditions. For example, temp &lt;- x &gt; 13 sets temp as a vector of the same length as x with values FALSE corresponding to elements of x where the condition is not met and TRUE where it is. The logical operators are &lt;, &lt;=, &gt;, &gt;=, == for exact equality and != for inequality. In addition if c1 and c2 are logical expressions, then c1&amp;c2 is their intersection (“and”), c1|c2 is their union (“or”), and !c1 is the negation of c1. z = 12 (8 &lt; z) &amp; (z &lt; 15) #Does z belong the interval (8,15) ## [1] TRUE Logical vectors may be used in ordinary arithmetic, in which case they are coerced into numeric vectors, FALSE becoming 0 and TRUE becoming 1. x &lt;- c(1, 1, 2, 4, 8, 1, 7, 1) sum(x == 1) #number of &quot;1&quot; in x ## [1] 4 3.5 Missing values In some cases, the components of a vector may not be completely known. When an element or value is “not available” or a “missing value” in the statistical sense, a place within a vector may be reserved for it by assigning it the special value NA. In general, any operation is incomplete; the result cannot be known, and hence is not available. The function is.na(x) gives a logical vector of the same size as x with value TRUE if and only if the corresponding element in x is NA. z &lt;- c(1:3, NA) ind &lt;- is.na(z) Notice that the logical expression x == NA is quite different from is.na(x) since NA is not really a value but a marker for a quantity that is not available. Thus, x == NA is a vector of the same length as x, all of whose values are NA as the logical expression itself is incomplete and hence undecidable. Note that there is a second kind of “missing” values which are produced by numerical computation, the so-called Not a Number, NaN values. Examples are 0 / 0 ## [1] NaN or Inf - Inf ## [1] NaN which both give NaN since the result cannot be defined sensibly. In summary, is.na(xx) is TRUE both for NA and NaN values. To differentiate these, is.nan(xx) is only TRUE for NaNs. Missing values are sometimes printed as when character vectors are printed without quotes. 3.6 Character Vectors Character quantities and character vectors are used frequently in R, for example, as plot labels. Where needed, they are denoted by a sequence of characters delimited by the double-quote character, e.g., “x-values”, “New iteration results”. Character strings are entered using either matching double (”) or single (’) quotes, but are printed using double quotes (or sometimes without quotes). Character vectors may be concatenated into a vector by the c() function; examples of their use will emerge frequently. The paste() function takes an arbitrary number of arguments and concatenates them one by one into character strings. Any numbers given among the arguments are coerced into character strings in an evident way, that is, in the same way, they would be if they were printed. The arguments are by default separated in the result by a single blank character, but this can be changed by the named parameter, sep=string, which changes it to string, possibly empty. For example, paste(&quot;I like&quot;, &quot;Statistics&quot;) ## [1] &quot;I like Statistics&quot; x = 2 paste(&quot;the value of x is&quot;, x) ## [1] &quot;the value of x is 2&quot; labs &lt;- paste(c(&quot;X&quot;,&quot;Y&quot;), 1:10, sep=&quot;&quot;) labs ## [1] &quot;X1&quot; &quot;Y2&quot; &quot;X3&quot; &quot;Y4&quot; &quot;X5&quot; &quot;Y6&quot; &quot;X7&quot; &quot;Y8&quot; &quot;X9&quot; ## [10] &quot;Y10&quot; This makes labs into the vector repeated 5 times to match the sequence 1:10. 3.7 Index Vectors Subsets of a vector’s elements may be selected by appending to the name of the vector an index vector in square brackets. More generally, any expression that evaluates to a vector may have subsets of its elements similarly selected by appending an index vector in square brackets immediately after the expression. Such index vectors can be any of four distinct types. A logical vector. In this case, the index vector must be of the same length as the vector from which elements are to be selected. Values corresponding to TRUE in the index vector are selected, and those corresponding to FALSE are omitted. For example y &lt;- x[!is.na(x)] creates (or re-creates) an object y which will contain the non-missing values of x, in the same order. Note that if x has missing values, y will be shorter than x. Also, (x+1)[(!is.na(x)) &amp; x &gt; 0] -&gt; z creates an object z and places in it the values of the vector x+1 for which the corresponding value in x was both non-missing and positive. A vector of positive integral quantities. In this case, the index vector’s values must lie in the set {1, 2, …, length(x)}. The corresponding elements of the vector are selected and concatenated, in that order, in the result. The index vector can be of any length, and the result is of the same length as the index vector. For example, x[6] is the sixth component of x and x[1:10] selects the first 10 elements of x (assuming length(x) is not less than 10). Also, options(width = 60) c(&quot;x&quot;, &quot;y&quot;)[rep(c(1, 2, 2, 1), times = 4)] ## [1] &quot;x&quot; &quot;y&quot; &quot;y&quot; &quot;x&quot; &quot;x&quot; &quot;y&quot; &quot;y&quot; &quot;x&quot; &quot;x&quot; &quot;y&quot; &quot;y&quot; &quot;x&quot; &quot;x&quot; &quot;y&quot; ## [15] &quot;y&quot; &quot;x&quot; produces a character vector of length 16 consisting of “x”, “y”, “y”, “x” repeated four times. A vector of negative integral quantities. Such an index vector specifies the values to be excluded rather than included. Thus y &lt;- x[-(1:5)] gives y all but the first five elements of x. A vector of character strings. This possibility only applies where an object has a names attribute to identify its components. In this case, a sub-vector of the names vector may be used in the same way as the positive integral labels in item 2 further above. fruit &lt;- c(5, 10, 1, 20) names(fruit) &lt;- c(&quot;orange&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;peach&quot;) fruit ## orange banana apple peach ## 5 10 1 20 fruit[c(&quot;apple&quot;,&quot;orange&quot;)] ## apple orange ## 1 5 The advantage is that alphanumeric names are often easier to remember than numeric indices. This option is particularly useful in connection with data frames, as we shall see later. An indexed expression can also appear on the receiving end of an assignment, in which case the assignment operation is performed only on those elements of the vector. The expression must be of the form vector[index_vector] as having an arbitrary expression in place of the vector name does not make much sense here. The vector assigned must match the length of the index vector, and in the case of a logical index vector, it must again be the same length as the vector it is indexing. For example, x[is.na(x)] &lt;- 0 replaces any missing values in x by zeros and y[y &lt; 0] &lt;- -y[y &lt; 0] has the same effect as y &lt;- abs(y) 3.8 Exercises: Create the vectors. (1, 2, 3, ..., 19, 20) (20, 19, ..., 2, 1) (1, 2, 3, ..., 19, 20, 19, 18, . . . , 2, 1) (4, 6, 3) and assign it to the vector tmp. Create a vector of the values of excos(x) at x = 3, 3.1, 3.2, …, 6 Create the following vectors. (0.13, 0.16, 0.19, ..., 0.136) (2, 22/2, 23/3, ..., 225/25) Use the function paste() to create the following character vectors of length 30: (\"label 1\", \"label 2\", ....., \"label 30\"). Note that there is a single space between label and the number following: (\"fn1\", \"fn2\", ..., \"fn30\"). In this case, there is no space between fn and the number following. 6.Calculate the following: \\[ \\Sigma_{i=10}^{100} i^3+4i^2 \\] Without using R, determine the result of the following computation: x &lt;- c(1, 2, 3) x[1]/x[2]^3 - 1 + 2 * x[3] - x[2 - 1] 1:5 + c(1, 2, 3) x1 &lt;- c(1, 4, 3, NA, 7) x2 &lt;- c(&quot;a&quot;, &quot;B&quot;, NA, &quot;NA&quot;) is.na(x1) is.na(x2) is.na(paste(c(1, NA))) x &lt;- c(1, 2, NA, 3) mean(x) mean(x, na.rm = TRUE) c(1, 2, 3)[4] Compute the real roots of the quadratic equation \\[ x^2+x+1=0 \\] Recall the formula for the roots of a quadratic \\[ x=\\frac{-b \\pm \\sqrt{b^2-4ac}}{2a} \\] Do the following for logical variables Create a logical vector x &lt;- seq(-3, 3, length = 200) &gt; 0 # negate this vector !x Compute the truth table for logical AND c(T, T, F, F) &amp; c(T, F, F, T) (c) Compute the truth table for logical OR c(T, T, F, F) &amp; c(T, F, F, T) Explore arithmetic with logical and numeric 1:3 + c(T, F, T) "],
["r-objects.html", "Chapter 4 R Objects 4.1 Introduction of R Objects 4.2 Data Structures 4.3 Exercises", " Chapter 4 R Objects 4.1 Introduction of R Objects The entities R operates on are technically known as objects. Examples are vectors of numeric (real) or complex values, vectors of logical values, and vectors of character strings. These are known as “atomic” structures since their components are all of the same type, or mode, namely numeric, complex, logical, character, and raw.Use the is() command to determine what an object is. 4.1.1 Mode of Objects Vectors must have their values all of the same mode. Thus any given vector must be unambiguously either logical, numeric, complex or character. Numeric is the default value type for most numbers. An integer is a subset of the numeric class, and may be used as a numeric value. You can perform any type of math or logical operation on numeric values, including: # Note that pi is a built-in constant, and log() the natural log function. log(3 * 4 * (2 + pi)) ## [1] 4.12227 # Basic logical operations, including &gt;, &lt;, &gt;= (greater than or equals), # &lt;= (less than or equals), == (exactly equals), and != (not equals). 2 &gt; 3 ## [1] FALSE # Advanced logical operations, including # &amp; (and), &amp;&amp; (if and only if), # | (or), and || (either or). 3 &gt;= 2 &amp;&amp; 100 == 1000/10 ## [1] TRUE Note that Inf (infinity), -Inf (negative infinity), NA (missing value), and NaN (not a number) are special numeric values on which most math operations will fail. (Logical operations will work, however.) Logical operations create logical values of either TRUE or FALSE. To convert logical values to numerical values, use the as.integer() command: as.integer(TRUE) ## [1] 1 as.integer(FALSE) ## [1] 0 Character values are text strings. For example, text &lt;- &quot;I like Statistics&quot; text ## [1] &quot;I like Statistics&quot; assigns the text string on the right-hand side of the &lt;- to the named object in your workspace. Note that a vector can be empty and still have a mode. For example the empty character string vector is listed as character(0) and the empty numeric vector as numeric(0). 4.1.2 Length of Objects By the mode of an object we mean the basic type of its fundamental constituents. This is a special case of a “property” of an object. Another property of every object is its length. The functions mode() and length() can be used to find out the mode and length of any defined structure. Changing the length of an object An “empty” object may still have a mode. For example, e &lt;- numeric() makes e an empty vector structure of mode numeric. Similarly, character() is an empty character vector, and so on. Once an object of any size has been created, new components may be added to it simply by giving it an index value outside its previous range. Thus, e[3] &lt;- 17 now makes e a vector of length 3, (the first two components of which are at this point both NA). This applies to any structure at all, provided the mode of the additional component(s) agrees with the mode of the object in the first place. 4.1.3 Getting and Setting Attributes The function attributes(object) returns a list of all the non-intrinsic attributes currently defined for that object. The function attr(object, name) can be used to select a specific attribute. These functions are rarely used, except in rather special circumstances when some new attribute is being created for some particular purpose, such as associating a creation date or an operator with an R object. When used on the left-hand side of an assignment, it can either associate a new attribute with the object or change an existing one. For example, z &lt;- 1:25 attr(z, &quot;dim&quot;) &lt;- c(5,5) z ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 6 11 16 21 ## [2,] 2 7 12 17 22 ## [3,] 3 8 13 18 23 ## [4,] 4 9 14 19 24 ## [5,] 5 10 15 20 25 allows R to treat z as if it were a 5x5 matrix. 4.1.4 The class of an object All objects in R have a class, reported by the function class. For simple vectors, this is just the mode, for example, “numeric”, “logical”, “character” or “list”, but “matrix”, “array”, “factor”, and “data.frame” are other possible values. A special attribute known as the class of the object is used to allow for an object-oriented style of programming in R. For example, if an object has class data.frame (we will discuss this shortly), it will be printed in a certain way, the plot() function will display it graphically in a certain way, and other so-called generic functions such as summary() will react to it as an argument in a way sensitive to its class. For example, if village has the class data.frame, then, age &lt;- 18:29 height &lt;- c(76.1, 77, 78.1, 78.2, 78.8, 79.7, 79.9, 81.1, 81.2, 81.8, 82.8, 83.5) #Build a dataframe village village &lt;- data.frame(age = age,height = height) village ## age height ## 1 18 76.1 ## 2 19 77.0 ## 3 20 78.1 ## 4 21 78.2 ## 5 22 78.8 ## 6 23 79.7 ## 7 24 79.9 ## 8 25 81.1 ## 9 26 81.2 ## 10 27 81.8 ## 11 28 82.8 ## 12 29 83.5 will print it in data frame form, which is rather like a matrix, and plot(village) summary(village) ## age height ## Min. :18.00 Min. :76.10 ## 1st Qu.:20.75 1st Qu.:78.17 ## Median :23.50 Median :79.80 ## Mean :23.50 Mean :79.85 ## 3rd Qu.:26.25 3rd Qu.:81.35 ## Max. :29.00 Max. :83.50 To remove temporarily the effects of class, use the function unclass(). unclass(village) ## $age ## [1] 18 19 20 21 22 23 24 25 26 27 28 29 ## ## $height ## [1] 76.1 77.0 78.1 78.2 78.8 79.7 79.9 81.1 81.2 81.8 82.8 ## [12] 83.5 ## ## attr(,&quot;row.names&quot;) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 attr(village,&quot;row.names&quot;) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 will print it as an ordinary list. 4.2 Data Structures 4.2.1 Arrays Arrays are data structures that consist of only one type of scalar value (e.g., a vector of character strings, or a matrix of numeric values). The most common versions, one-dimensional and two-dimensional arrays, are known as vectors and matrices, respectively. Ways to create arrays Common ways to create vectors (or one-dimensional arrays) include: # Concatenates numeric values into a vector a &lt;- c(3, 7, 9, 11) # Concatenates character strings into a vector a &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) # Creates a vector of integers from 1 to 5 inclusive a &lt;- 1:5 # Creates a vector of 5 repeated ‘1’s a &lt;- rep(1, times = 5) To manipulate a vector: # Extracts the 10th value from the vector ‘a’ a[10] # Inserts 3.14 as the 5th value in the vector ‘a&#39; a[5] &lt;- 3.14 # Replaces the 5-7th values with 2, 4, and 7 a[5:7] &lt;- c(2, 4, 7) Unlike larger arrays, vectors can be extended without first creating another vector of the correct length. Hence, a &lt;- c(4, 6, 8) # Inserts a 9 in the 5th position of the vector a[5] &lt;- 9 A factor vector is a special type of vector that allows users to create j indicator variables in one vector, rather than using j dummy variables (as in Stata or SPSS). R creates this special class of vector from a pre-existing vector x using the factor() command, which separates x into levels based on the discrete values observed in x. These values may be either integer value or character strings. For example, x &lt;- c(1, 1, 1, 1, 1, 2, 2, 2, 2, 9, 9, 9, 9) # Notice levels are printed. factor(x) ## [1] 1 1 1 1 1 2 2 2 2 9 9 9 9 ## Levels: 1 2 9 By default, factor() creates unordered factors, which are treated as discrete, rather than ordered, levels. Add the optional argument ordered = TRUE to order the factors in the vector: x &lt;- c(&quot;like&quot;, &quot;dislike&quot;, &quot;hate&quot;, &quot;like&quot;, &quot;don&#39;t know&quot;, &quot;like&quot;, &quot;dislike&quot;) factor(x, levels = c(&quot;hate&quot;, &quot;dislike&quot;, &quot;like&quot;, &quot;don&#39;t know&quot;), ordered = TRUE) ## [1] like dislike hate like don&#39;t know ## [6] like dislike ## Levels: hate &lt; dislike &lt; like &lt; don&#39;t know If you omit the levels command, R will order the values according to the alphabetic order. factor(x, ordered = TRUE) ## [1] like dislike hate like don&#39;t know ## [6] like dislike ## Levels: dislike &lt; don&#39;t know &lt; hate &lt; like If you omit one or more of the levels in the list of levels, R returns levels values of NA for the missing level(s): factor(x, levels = c(&quot;hate&quot;, &quot;dislike&quot;, &quot;like&quot;), ordered = TRUE) ## [1] like dislike hate like &lt;NA&gt; like dislike ## Levels: hate &lt; dislike &lt; like Build matrices (or two-dimensional arrays) from vectors (one-dimensional arrays). You can create a matrix in two ways: From a vector: Use the command matrix(vector, nrow = k, ncol = n) to create a k × n matrix from the vector by filling in the columns from left to right. For example, matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, ncol = 3) ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 From two or more vectors of length k: Use cbind() to combine n vectors vertically to form a k × n matrix, or rbind() to combine n vectors horizontally to form a n × k matrix. For example: # Creates a vector `x&#39; of 3 values. x &lt;- c(11, 12, 13) # Creates another vector `y&#39; of 3 values. y &lt;- c(55, 33, 12) # Creates a 2 x 3 matrix. rbind(x, y) ## [,1] [,2] [,3] ## x 11 12 13 ## y 55 33 12 Note that row 1 is named x and row 2 is named y, according to the order in which the arguments were passed to rbind(). cbind(x, y) ## x y ## [1,] 11 55 ## [2,] 12 33 ## [3,] 13 12 creates a 3 x 2 matrix. Note that the columns are named according to the order in which they were passed to cbind(). R supports a variety of matrix functions, including: det(), which returns the matrix’s determinant; t(), which transposes the matrix; solve(), which inverts the the matrix; and %*%, which multiplies two matricies. In addition, the dim() command returns the dimensions of your matrix. As with vectors, square brackets extract specific values from a matrix and the assignment mechanism &lt;- replaces values. For example: # Extracts the third column of Iowa. Iowa[,3] # Extracts the first row of Iowa. Iowa[1,] # Inserts 13 as the value for row 1, column 3. Iowa[1,3] &lt;- 13 # Replaces the first row of Iowa. Iowa[1,] &lt;- c(2,2,3) If you encounter problems replacing rows or columns, make sure that the dims() of the vector matches the dims() of the matrix you are trying to replace. An n-dimensional array is a set of stacked matrices of identical dimensions. For example, you may create a three dimensional array with dimensions (2, 3, 2) by stacking 2 matrices each with 2 rows and 3 columns, so there are 2 x 3 x 2 = 12 entries in this array. # Creates a 2 x 3 matrix populated with 8&#39;s. a &lt;- matrix(8, 2, 3) # Creates a 2 x 3 matrix populated with 9&#39;s. b &lt;- matrix(9, 2, 3) array(c(a, b), c(2, 3, 2)) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 8 8 8 ## [2,] 8 8 8 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 9 9 9 ## [2,] 9 9 9 creates a 2 x 3 x 2 array with the first level [ , ,1] populated with matrix a (8’s), and the second level [ , ,2] populated with matrixb (9’s). It uses square brackets to extract values. For example, [1, 2, 2] extracts the second value in the first row of the second level. You may also use the &lt;- operator to replace values. If an array is a one-dimensional vector or two-dimensional matrix, R will treat the array using the more specific method. Three functions especially helpful for arrays: is() returns both the type of scalar value that populates the array, as well as the specific type of array (vector, matrix, or array more generally). dim() returns the size of an array, where dim(b) ## [1] 2 3 indicates that the array is two-dimensional (a matrix), and has 33 rows and 5 columns. The single bracket [ ] indicates specific values in the array. Use commas to indicate the index of the specific values you would like to pull out or replace: dim(a) # Pull out the 10th value in the vector &#39;a&#39; a[10] dim(b) # Pull out the first 12 rows of &#39;b&#39; b[1:12, ] # Pull out the value in the first row, second column of &#39;c&#39; c[1, 2] dim(d) # Pulls out a vector of 1,000 values d[ , 3, 1] Apply The apply function offers a very elegant way of handling arrays and matrices. It works by successfully applying the function of your choice to each row (first dimension), each column (second dimension), or each level of a higher dimension. The syntax is apply(data, dim, function, ...) data is the names of your matrix or array, and function is the name of any R function that want to apply to your data. For a matrix of two dimensions, the option dim can take the integer value of or 2 to refer to the rows or columns, respectively. The option, …, can be filled in with options to be passed on to the function being specifies. We can use such a function to compute the maximum value of each column of a matrix a &lt;- matrix(8, 2, 3) apply(a, 2, max) ## [1] 8 8 8 4.2.2 Lists Unlike arrays, which contain only one type of scalar value, lists are flexible data structures that can contain heterogeneous value types and heterogeneous data structures. Lists are so flexible that one list can contain another list. For example, the list output can contain coef, a vector of regression coefficients; variance, the variance-covariance matrix; and another list terms that describes the data using character strings. Use the names() function to view the named elements in a list, and to extract a named element, use names(output) For lists where the elements are not named, use double square brackets [[ ]] to extract elements: # Extracts the 4th element from the list &#39;L&#39; L[[4]] # Replaces the 4th element of the list &#39;L&#39; with a matrix &#39;b&#39; L[[4]] &lt;- b Like vectors, lists are flexible data structures that can be extended without first creating another list of with the correct number of elements: # Creates an empty list L &lt;- list() # Inserts a vector, and names that vector &#39;coefficients&#39; L$coefficients &lt;- c(1, 4, 6, 8) # Pull out the value in the first row, second column of &#39;c&#39; # within the list, inserts the vector into the 4th position # in the list. If this list doesn&#39;t already have 4 elements, # the empty elements will be &#39;NULL&#39; values L[[4]] &lt;- c(1, 4, 6, 8) Alternatively, you can easily create a list using objects that already exist in your workspace: # Where &#39;k&#39; is a vector and &#39;v&#39; is a matrix L &lt;- list(coefficients = k, variance = v) 4.2.3 Data Frames A data frame (or data set) is a special type of list in which each variable is constrained to have the same number of observations. A data frame may contain variables of different types (numeric, integer, logical, character, and factor), so long as each variable has the same number of observations. grp &lt;- c(1, 2, 2, 1, 1, 1, 2, 2, 1, 2, 2, 1) gpa &lt;- c(4, 3.5, 2.8, 3.9, 2.2, 3.8, 2.7, 3.8, 4, 3.6, 3.4, 2.1) age &lt;- c(21, 22, 19, 32, 25, 22, 20, 23, 21, 24, 22, 30) sex &lt;- c(&quot;F&quot;, &quot;M&quot;, &quot;M&quot;, &quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;, &quot;F&quot;) # Build a dataframe dat dat &lt;- data.frame(grp = grp, gpa = gpa, age = age, sex = sex) dat ## grp gpa age sex ## 1 1 4.0 21 F ## 2 2 3.5 22 M ## 3 2 2.8 19 M ## 4 1 3.9 32 M ## 5 1 2.2 25 F ## 6 1 3.8 22 F ## 7 2 2.7 20 M ## 8 2 3.8 23 M ## 9 1 4.0 21 F ## 10 2 3.6 24 M ## 11 2 3.4 22 F ## 12 1 2.1 30 F Thus, a data frame can use both matrix commands and list commands to manipulate variables and observations. # Extracts obs. 1-10 and all associated variables dat[1:10,] ## grp gpa age sex ## 1 1 4.0 21 F ## 2 2 3.5 22 M ## 3 2 2.8 19 M ## 4 1 3.9 32 M ## 5 1 2.2 25 F ## 6 1 3.8 22 F ## 7 2 2.7 20 M ## 8 2 3.8 23 M ## 9 1 4.0 21 F ## 10 2 3.6 24 M # Extracts all observations that belong to group 1 dat[dat$grp == 1,] ## grp gpa age sex ## 1 1 4.0 21 F ## 4 1 3.9 32 M ## 5 1 2.2 25 F ## 6 1 3.8 22 F ## 9 1 4.0 21 F ## 12 1 2.1 30 F # Saves the variable &#39;grp&#39; as a vector &#39;group&#39; in # the workspace, not in the data frame group &lt;- dat$grp # Saves the 4th variable as a &#39;var4&#39; in the workspace var4 &lt;- dat[[4]] 4.2.4 Frequency Tables From Factors Recall that a factor defines a partition into groups. Similarly a pair of factors defines a two way cross classification, and so on. The function table() allows frequency tables to be calculated from equal length factors. If there are k factor arguments, the result is a k-way array of frequencies. Suppose, for example, we have a sample of 30 tax accountants from all the states and territories of Australia1 and their individual state of origin is specified by a character vector of state mnemonics as state &lt;- c(&quot;tas&quot;, &quot;sa&quot;, &quot;qld&quot;, &quot;nsw&quot;, &quot;nsw&quot;, &quot;nt&quot;, &quot;wa&quot;, &quot;wa&quot;, &quot;qld&quot;, &quot;vic&quot;, &quot;nsw&quot;, &quot;vic&quot;, &quot;qld&quot;, &quot;qld&quot;, &quot;sa&quot;, &quot;tas&quot;, &quot;sa&quot;, &quot;nt&quot;, &quot;wa&quot;, &quot;vic&quot;, &quot;qld&quot;, &quot;nsw&quot;, &quot;nsw&quot;, &quot;wa&quot;, &quot;sa&quot;, &quot;act&quot;, &quot;nsw&quot;, &quot;vic&quot;, &quot;vic&quot;, &quot;act&quot;) Notice that in the case of a character vector, “sorted” means sorted in alphabetical order. A factor is similarly created using the factor() function: statef &lt;- factor(state) statef ## [1] tas sa qld nsw nsw nt wa wa qld vic nsw vic qld qld ## [15] sa tas sa nt wa vic qld nsw nsw wa sa act nsw vic ## [29] vic act ## Levels: act nsw nt qld sa tas vic wa To find out the levels of a factor the function levels() can be used. levels(statef) ## [1] &quot;act&quot; &quot;nsw&quot; &quot;nt&quot; &quot;qld&quot; &quot;sa&quot; &quot;tas&quot; &quot;vic&quot; &quot;wa&quot; The assignment statefr &lt;- table(statef) gives statefr a table of frequencies of each state in the sample. The table() command can also summarize bivariate data in a similar manner as it summarized univariate data. Suppose a student survey is done to evaluate if students who smoke study less. The data recorded is Person Smokes amount of Studying 1 Y less than 5 hours 2 N 5 - 10 hours 3 N 5 - 10 hours 4 Y more than 10 hours 5 N more than 10 hours 6 Y less than 5 hours 7 Y 5 - 10 hours 8 Y less than 5 hours 9 N more than 5 hours 10 Y 5 - 10 hours We can handle this in R by creating two vectors to hold our data, and then using the table command. smokes = c(&quot;Y&quot;, &quot;N&quot;, &quot;N&quot;, &quot;Y&quot;, &quot;N&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;Y&quot;, &quot;N&quot;, &quot;Y&quot;) amount = c(1, 2, 2, 3, 3, 1, 2, 1, 3, 2) table(smokes,amount) ## amount ## smokes 1 2 3 ## N 0 2 2 ## Y 3 2 1 4.3 Exercises Create the following matrices \\(\\mathbf{a} = \\begin{bmatrix} 1 &amp; 2 &amp; 3\\end{bmatrix}\\); \\(\\mathbf{C} = \\begin{bmatrix} 3 &amp; 2 \\\\ 6 &amp; 4\\end{bmatrix}\\); \\(\\mathbf{I} = \\begin{bmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1\\end{bmatrix}\\); \\(\\mathbf{O} = \\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\end{bmatrix}\\). Find \\(\\mathbf{aa&#39;}\\) and \\(\\mathbf{a&#39;a}\\) and \\(\\mathbf{C}^{-1}\\). Without running R, guess the following A &lt;- matrix(c(2, 4, 3, 1, 5, 7), nrow = 2, ncol = 3, byrow = TRUE) A A[2, 3] A[2, ] A[, c(1, 3)] t(A) Without running R, guess the following n &lt;- c(2, 3, 5) s &lt;- c(&quot;aa&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;dd&quot;, &quot;ee&quot;) b &lt;- c(TRUE, FALSE, TRUE, FALSE, FALSE) x &lt;- list(n, s, b, 3) # x contains copies of n, s, b x[2] x[[2]][1] "],
["exportimport-data.html", "Chapter 5 Export/Import Data 5.1 Data Export 5.2 Data Import", " Chapter 5 Export/Import Data In this chapter, you’ll learn how to read plain-text rectangular files into R, and how to export data from R to txt, csv, and R data file formats. 5.1 Data Export Using function cat() The function cat is useful for producing output in user-defined functions. cat(&quot;Good morning!&quot;,&quot;\\n&quot;) #\\n: newline ## Good morning! cat(file = &quot;test.txt&quot;, &quot;123456&quot;, &quot;987654&quot;, sep = &quot;\\n&quot;) Using function print() The function print prints its argument. It is a generic function which means that new printing methods can be easily added for new classes. print(&quot;Good morning!&quot;) ## [1] &quot;Good morning!&quot; Write a matrix or data frame to file The commonest task is to write a matrix or data frame to file as a rectangular grid of numbers, possibly with row and column labels. This can be done by the functions write.table and write. Command to copy and paste from R into Excel or other programs. It writes the data of an R data frame object into the clipboard from where it can be pasted into other applications. age &lt;- 18:29 height &lt;- c(76.1, 77, 78.1, 78.2, 78.8, 79.7, 79.9, 81.1, 81.2, 81.8, 82.8, 83.5) village &lt;- data.frame(age = age,height = height) # Write village into clipboard write.table(village, &quot;clipboard&quot;, sep = &quot;\\t&quot;, col.names = NA, quote = F) Remark: The argument quote is a logical value (TRUE or FALSE) or a numeric vector. If TRUE, any character or factor columns will be surrounded by double quotes. If FALSE, nothing is quoted. The argument col.names= NA makes sure that the titles align with columns when row/index names are exported (default). Write data frame to a tab-delimited text file. write.delim(village, file = &quot;village.txt&quot;) # provides same results as read.delim write.table(village, file = &quot;village.txt&quot;, sep = &quot;\\t&quot;) Write data to csv files: write.csv(village, file = &quot;village.csv&quot;) Write matrix data to a file. x &lt;- matrix(1, 20, 20) write(x, file = &quot;file path&quot;, ncolumns = 20) Remark: write.table() is the multipurpose work-horse function in base R for exporting data. The functions write.csv() and write.delim() are special cases of write.table() in which the defaults have been adjusted for efficiency. 5.1.1 .RData files The best way to store objects from R is with .RData files. .RData files are specific to R and can store as many objects as you’d like within a single file. ** The save() function age &lt;- 18:29 height &lt;- c(76.1, 77, 78.1, 78.2, 78.8, 79.7, 79.9, 81.1, 81.2, 81.8, 82.8, 83.5) village &lt;- data.frame(age = age, height = height) # Save the object as a new .RData file save(village, file = &quot;data/village.rda&quot;) To save selected objects into one .RData file, use the save() function. When you run the save() function with specific objects as arguments, (like save(a, b, c, file = \"myobjects.RData\") all of those objects will be saved in a single file called myobjects.RData. For example, let’s create a few objects corresponding to a study. # Create two objects student.df &lt;- data.frame(id = 1:5, sex = c(&quot;m&quot;, &quot;f&quot;, &quot;m&quot;, &quot;f&quot;, &quot;m&quot;), score = c(90, 80, 97, 62, 82)) score.by.sex &lt;- aggregate(score ~ sex, FUN = mean, data = student.df) # Save two objects as a new .RData file save(student.df, score.by.sex, file = &quot;data/student.rda&quot;) 5.2 Data Import 5.2.1 The load() function To load an .RData file, that is, to import all of the objects contained in the .RData file into your current workspace, use the load() function. For example, to load the three specific objects that I saved earlier (study1.df, score.by.sex) in study1.rda, I’d run the following: # Load objects in village.rda into my workspace load(file = &quot;data/village.rda&quot;) To load all of the objects in the workspace that we have saved to the data folder in a working directory named projectnew.rda, we can run the following: # Load objects in projectnew.rda into my workspace load(file = &quot;data/projectnew.rda&quot;) 5.2.2 The read.table() function Large data objects will usually be read as values from external files rather than entered during an R session at the keyboard. R input facilities are simple, and their requirements are fairly strict and even rather inflexible. If variables are to be held mainly in data frames, as we strongly suggest they should be, an entire data frame can be read directly with the read.table() function. There is also a more primitive input function, scan(), that can be called directly. For more details on importing data into R and also exporting data, see the R Data Import/Export manual. To read an entire data frame directly, the external file will typically have a special form. The first line of the file should have a name for each variable in the data frame. Each additional line of the file has its first item, a row label, and the values for each variable. By default, numeric items (except row labels) are read as numeric variables and non-numeric variables, such as name and gender in the above example, as factors. The function read.table() can then be used to read the data frame directly. For the file, scores_names.txt, you might want to omit, including the row labels, directly and use the default labels. In this case, the file may omit the row label column as in the following. scores &lt;- read.table(&quot;scores_names.txt&quot;, header = TRUE) scores[[&#39;gender&#39;]] scores[[&#39;aptitude&#39;]] where the header=TRUE option specifies that the first line is a line of headings, and hence, by implication from the form of the file, that no explicit row labels are given. This can be changed if necessary. scores &lt;- read.table(&quot;scores_names.txt&quot;, colClasses = c(&quot;character&quot;, &quot;character&quot;, &quot;integer&quot;, &quot;integer&quot;), header = TRUE) &gt; scores[[&#39;gender&#39;]] If the values are separated by commas or another “delimiter,” we have to specify the delaminating character(s). For example, look at the file reading.txt on the Blackboard folder. reading &lt;- read.table(&quot;reading.txt&quot;, sep = &quot;,&quot;) # names() is to get or set the names of an object. names(reading) = c(&quot;Name&quot;, &quot;Week1&quot;, &quot;Week2&quot;, &quot;Week3&quot;, &quot;Week4&quot;, &quot;Week5&quot;) print(reading) If sep = \"\" (the default for read.table) the separator is ‘white space’, that is one or more spaces, tabs, newlines or carriage returns. 5.2.3 The scan() function In fact read.table() uses scan() to read the file, and then process the results of scan. It is very convenient, but sometimes it is better to use scan() directly. The function scan() at its simplest can do the same as c. It saves you having to type the commas though: z &lt;- scan() z Note that we start typing the numbers in z. If we hit the return key once we continue on a new row, if we hit it twice in a row, the scan stops. This can be fairly convenient when entering in a few data points (10-40 say). Using scan with a file The file ReadWithScan.txt in your drive has contents 1 2 3 4 Then, the command x = scan(file = &quot;ReadWithScan.txt&quot;) will read the contents into your R session. Now suppose you had some formatting between the numbers you want to get rid of for example this is now your file ReadWithScan.txt 1, 2, 3, 4 then x &lt;- scan(file = &quot;ReadWithScan.txt&quot;, sep = &quot;,&quot;) works. The function scan has many arguments in common with read.table. One additional argument is what, which specifies a list of modes of variables to be read from the file. If the list is named, the names are used for the components of the returned list. Modes can be numeric, character or complex, and are usually specified by an example, e.g., 0 or \"\". Suppose the data vectors are of equal length and are to be read in parallel. Further, suppose that there are three vectors, the first of mode character and the remaining two of mode numeric, and the file is ‘input.dat’. The first step is to use scan() to read in the three vectors as a list, as follows: inp &lt;- scan(&quot;ReadWithScan2.txt&quot;, list(&quot;&quot;,0,0)) Read 3 records: [[1]] [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; [[2]] [1] 2 2 6 [[3]] [1] 1 3 7 The second argument is a dummy list structure that establishes the mode of the three vectors to be read. The result, held in inp, is a list whose components are the three vectors read in. To separate the data items into three separate vectors, use assignments like label &lt;- inp[[1]]; x &lt;- inp[[2]]; y &lt;- inp[[3]] More conveniently, the dummy list can have named components, in which case the names can be used to access the vectors read in. For example, scan(&quot;ReadWithScan2.txt&quot;, list(id = &quot;&quot;, x = 0, y = 0)) There are more elaborate input facilities available and these are detailed in the manuals. 5.2.4 The read.csv() function Alternatively, you may have data from a spreadsheet. The simplest way to enter this into R is through a file format. Typically, this is a CSV format (comma-separated values). First, save the data from the spreadsheet as a CSV file say data.csv. Then the R command read.csv will read it in as follows x &lt;- read.csv(file=&quot;data.csv&quot;) CSV file can be comma delimited or tab or any other delimiter specified by parameter sep =. If the parameter header = is TRUE, then the first row will be treated as the row names. read.csv(file, header = FALSE, sep = &quot;,&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;.&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) read.csv2(file, header = TRUE, sep = &quot;;&quot;, quote = &quot;\\&quot;&quot;, dec = &quot;,&quot;, fill = TRUE, comment.char = &quot;&quot;, ...) file: file name header: 1st line as header or not, logical sep: field separator quote: quoting characters … The difference between read.csv and read.csv2 is the default field seperator, as “,” and “;” respectively. Following is a csv file example: t1 t2 t3 t4 t5 t6 t7 t8 r1 1 0 1 0 0 1 0 2 r2 1 2 2 1 2 1 2 1 r3 0 0 0 2 1 1 0 1 r4 0 0 1 1 2 0 0 0 r5 0 2 1 1 1 0 0 0 r6 2 2 0 1 1 1 0 0 r7 2 2 0 1 1 1 0 1 r8 0 2 1 0 1 1 2 0 r9 1 0 1 2 0 1 0 1 r10 1 0 2 1 2 2 1 0 r11 1 0 0 0 1 2 1 2 r12 1 2 0 0 0 1 2 1 r13 2 0 0 1 0 2 1 0 r14 0 2 0 2 1 2 0 2 r15 0 0 0 2 0 2 2 1 r16 0 0 0 1 2 0 1 0 r17 2 1 0 1 2 0 1 0 r18 1 1 0 0 1 0 1 2 r19 0 1 1 1 1 0 0 1 r20 0 0 2 1 1 0 0 1 x &lt;- read.csv(&quot;readcsv.csv&quot;, header = T, dec = &quot;.&quot;, sep = &quot;\\t&quot;) is.data.frame(x) 5.2.5 Import an Excel file into R You can import an excel file using the readxl package. To start, here is a template that you can use to import an Excel file into R: library(&quot;readxl&quot;) read_excel(&quot;&lt;name and extension of your file&gt;&quot;) If you want to import a specific sheet within the Excel file, you may use this template: library(&quot;readxl&quot;) read_excel(&quot;&lt;name and extension of the file&gt;&quot;, sheet = &quot;sheet name&quot;) If you want to set a three column excel sheet to contain the data as dates in the first column, characters in the second, and numeric values in the third, you would need the following lines of code: library(&quot;readxl&quot;) read_excel(&quot;&lt;name and extension of your file&gt;&quot;, col_types = c(&quot;date&quot;, &quot;numeric&quot;, &quot;text&quot;)) 5.2.6 Accessing built-in datasets Around 100 datasets are supplied with R (in package datasets), and others are available in packages (including the recommended packages supplied with R). To see the list of datasets currently available use data(). As from R version 2.0.0 all the datasets supplied with R are available directly by name. AirPassengers However, many packages still use the earlier convention in which data was also used to load datasets into R, for example, data(AirPassengers) and this can still be used with the standard packages. In most cases this will load an R object of the same name. However, in a few cases it loads several objects, so see the on-line help for the object to see what to expect. Loading data from other R packages To access data from a particular package, use the package argument, for example, data(package = &quot;rpart&quot;) data(Puromycin, package = &quot;datasets&quot;) Figure 5.1 shows a subset oof supported file formats. Figure 5.1: A non-inclusive list of supported file formats. "],
["visualization.html", "Chapter 6 Visualization 6.1 Bar Chart 6.2 Pie charts 6.3 Stem-and-leaf Charts 6.4 Histograms 6.5 Boxplot 6.6 Scatterplot 6.7 Line plots and Time series plots 6.8 Visualization using ggplot2 6.9 Exercises", " Chapter 6 Visualization 6.1 Bar Chart A bar chart draws a bar with a height proportional to the count in the table. The height could be given by the frequency or the proportion. The graph will look the same, but the scales may be different. Suppose a group of 25 people are surveyed as to their beer-drinking preference. The categories were (1) Domestic can, (2) Domestic bottle, (3) Microbrew, and (4) import. The raw data is 3 4 1 1 3 4 3 3 1 3 2 1 2 1 2 3 2 3 1 1 1 1 4 3 1 Let’s make a barplot of both frequencies and proportions. First, we use the scan function to read in the data: beer &lt;- c(3, 4, 1, 1, 3, 4, 3, 3, 1, 3, 2, 1, 2, 1, 2, 3, 2, 3, 1, 1, 1, 1, 4, 3, 1) then we plot a bar chart: par(mfrow = c(1,3)) # This isn&#39;t correct barplot(beer) # Yes, call with summarized data barplot(table(beer)) # Divide by n for proportion barplot(table(beer) / length(beer)) Figure 6.1: Bar chart examples We did 3 barplots in Figure 6.1. The first to show that we don’t use barplot with the raw data. The second shows the use of the table command to create summarized data, and the result of this is sent to barplot creating the barplot of frequencies shown. Finally, the command table(beer)/length(beer) ## beer ## 1 2 3 4 ## 0.40 0.16 0.32 0.12 produces the proportions first. We divide it by the number of data points, which is 25 or length(beer). The result is then handed off to barplot to make a graph. Notice it has the same shape as the previous one, but the height axis is now between 0 and 1 as it measures the proportion and not the frequency. This is ugly, you can change the color by specifying col; see Figure 6.2. barplot(table(beer) / length(beer), col = c(&quot;lightblue&quot;, &quot;mistyrose&quot;, &quot;lightcyan&quot;, &quot;cornsilk&quot;)) Figure 6.2: A colored bar chart example 6.2 Pie charts The same data can be studied with pie charts using the pie function. Here are some simple examples illustrating the usage (similar to barplot(), but with some added features. See Figure 6.3. par(mfrow = c(1,3)) # Store the table result beer.counts &lt;- table(beer) # First pie -- kind of dull pie(beer.counts) # Give names names(beer.counts) &lt;- c(&quot;domestic\\n can&quot;, &quot;Domestic\\n bottle&quot;, &quot;Microbrew&quot;, &quot;Import&quot;) # Prints out names pie(beer.counts) # Now with colors pie(beer.counts, col = c(&quot;purple&quot;, &quot;green2&quot;, &quot;cyan&quot;, &quot;white&quot;)) Figure 6.3: Pie chart plotting examples. The first one was kind of boring, so we added names. This is done with the names(), which allows us to specify names to the categories. The resulting piechart shows how the names are used. Finally, we added color to the piechart. This is done by setting the piechart attribute col. We set this equal to a vector of color names that was the same length as our beer.counts. The help command (?pie) gives some examples for automatically getting different colors, notably using rainbow and gray. Notice we used additional arguments to the function pie. The syntax for these is name=value. The ability to pass in named values to a function makes it easy to have fewer functions as each one can have more functionality. 6.3 Stem-and-leaf Charts If the data set is relatively small, the stem-and-leaf diagram is handy for seeing the shape of the distribution and the values. The number on the left of the bar is the stem, the number on the right the digit. You put them together to find the observation. Suppose you have the box score of a basketball game and find the following points per game for players on both teams: 2 3 16 23 14 12 4 13 2 0 0 0 6 28 31 14 4 8 2 5 scores &lt;- c(2, 3, 16, 23, 14, 12, 4, 13, 2, 0, 0, 0, 6, 28, 31, 14, 4, 8, 2, 5) # What exactly is the name? apropos(&quot;stem&quot;) ## [1] &quot;R_system_version&quot; &quot;stem&quot; &quot;system&quot; ## [4] &quot;system.file&quot; &quot;system.time&quot; &quot;system2&quot; To create a stem and leaf chart is simple: stem(scores) ## ## The decimal point is 1 digit(s) to the right of the | ## ## 0 | 000222344568 ## 1 | 23446 ## 2 | 38 ## 3 | 1 Notice we use apropos() to help find the name for the function. It is stem() and not stemleaf(). The apropos() command is convenient when you think you know the function’s name but aren’t sure. Suppose we wanted to break up the categories into groups of 5. We can do so by setting the “scale” stem(scores, scale = 2) ## ## The decimal point is 1 digit(s) to the right of the | ## ## 0 | 000222344 ## 0 | 568 ## 1 | 2344 ## 1 | 6 ## 2 | 3 ## 2 | 8 ## 3 | 1 6.4 Histograms If there is too much data, or your audience doesn’t know how to read the stem-and-leaf, you might try other summaries. The most common is similar to the bar plot and is a histogram. The histogram defines a sequence of breaks and then counts the number of observations in the bins formed by the breaks. (This is identical to the features of the cut() function.) It plots these with a bar similar to the bar chart, but the bars are touching. The height can be the frequencies or proportions. Let’s begin with a simple example. Suppose the top 25 ranked movies made the following gross receipts for a week 4 29.6 28.2 19.6 13.7 13.0 7.8 3.4 2.0 1.9 1.0 0.7 0.4 0.4 0.3 0.3 0.3 0.3 0.3 0.2 0.2 0.2 0.1 0.1 0.1 0.1 0.1 We now make some histograms: x &lt;- c(29.6, 28.2, 19.6, 13.7, 13.0, 7.8, 3.4, 2.0, 1.9, 1.0, 0.7, 0.4, 0.4, 0.3, 0.3, 0.3, 0.3, 0.3, 0.2, 0.2, 0.2, 0.1, 0.1, 0.1, 0.1, 0.1) par(mfrow = c(1,2)) hist(x) # frequencies hist(x, probability = TRUE) # proportions (or probabilities) Figure 6.4: Examples of histogram. Two graphs are shown in Figure 6.4. The first is the default graph which makes a histogram of frequencies (total counts). The second does a histogram of proportions which makes the total area add to 1. This is preferred as it relates better to the concept of a probability density. Note the only difference is the scale on the y axis. The basic histogram has a predefined set of break points for the bins. If you want, you can specify the number of breaks or your own break points; see Figure 6.5. par(mfrow = c(1, 2)) # Specify 10 breaks, or just hist(x, 10) hist(x, breaks = 10) # Specify break points hist(x, breaks = c(0, 1, 2, 3, 4, 5, 10, 20, max(x))) Figure 6.5: More examples of histogram. 6.5 Boxplot The boxplot is used to summarize data succinctly, quickly displaying if the data is symmetric or has suspected outliers. It is based on the 5-number summary. 6.5.1 Boxplot: one sample The basic function is boxplot() Example: Suppose we have 11 observations: 7 9.5 10 11 10 10 8 11 18 13 11.5 Figure 6.6 shows a basic boxplot. x &lt;- c(7, 9.5, 10, 11, 10, 10, 8, 11, 18, 13, 11.5) boxplot(x, horizontal = TRUE) Figure 6.6: An example of boxplot. We can add axis labels, a main title and color the box using simple commands; see Figure 6.7. boxplot(x, xlab = &quot;Single sample&quot;, ylab = &quot;Value axis&quot;, main = &quot;Simple Box plot&quot;, col = &quot;lightblue&quot;) Figure 6.7: An example of boxplot with title and colored box. 6.5.2 Plotting several samples So we can see how to represent a single sample but often we wish to compare samples. For example, we may have raised broods of flies on various sugars. We measure the size of the individual flies and record the diet for each. Our data file would consist of two columns; one for growth and one for sugar. For example, growth sugar 75 C 72 C 73 C 61 F 67 F 64 F 62 S 63 S growth &lt;- c(75, 72, 73, 61, 67, 64, 62, 63) sugar &lt;- c(&quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;S&quot;, &quot;S&quot;) fly &lt;- data.frame(growth = growth, sugar = sugar) To plot these we use the boxplot command with slightly different syntax e.g. boxplot(y ~ x). This model syntax is used widely in R for setting-up regression analyses for example. To create a summary boxplot in Figure 6.8 we type something like: boxplot(growth ~ sugar, data = fly, xlab = &quot;Sugar type&quot;, ylab = &quot;Growth&quot;, col = &quot;bisque&quot;, range = 0) title(main = &quot;Growth against sugar type&quot;, font.main = 4) Figure 6.8: An example of side by side boxplot. Now we can see that the different sugar treatments appear to produce differing growth in our subjects. 6.6 Scatterplot Often we wish to investigate one numerical variable against another. For example the height of a father compared to their sons height. 6.6.1 Basic command As usual with R there are many additional parameters that you can add to customize your plots. The basic command is: plot(x, y) where x is the name of your x-variable and y is the name of your y-variable. This is fine if you have two variables but if they are part of a bigger data set, then you can use command plot(y ~ x, data = your.data) Note the use of the model syntax. This model syntax is used widely in R for setting-up ANOVA and regression analyses for example (see also it’s use in the boxplot). R comes with a number of data sets built-in; these are used in the examples and can be useful to ‘play with’. For example, the data set cars contains two variables speed and dist. To see a basic scatter plot like Figure 6.9 try the following: plot(dist ~ speed, data = cars) Figure 6.9: A simple example of scatterplot. This basic scatterplot takes the axes labels from the variables and uses open circles as the plotting symbol. Additional commands with regression fit As usual with R we have a wealth of additional commands at our disposal to beef up the display. A useful additional command is to add a line of best-fit. This is a command that adds to the current plot (like the title() command). For the above example we’d type: plot(dist ~ speed, data = cars) abline(lm(dist ~ speed, data = cars)) Figure 6.10: A scatterplot with fitted regression line. The basic command uses abline(a, b), where a=slope and b=intercept. Here we use a linear model command to calculate the best-fit equation for us (try typing the lm() command separately, you get the intercept and slope) as shown in Figure 6.10. If we combine this with a couple of extra lines we can produce a better looking plot in Figure 6.11: plot(dist ~ speed, data = cars, xlab = &quot;Speed&quot;, ylab = &quot;Distance&quot;, col = &quot;blue&quot;) title(main = &quot;Scatter plot with best-fit line&quot;, font.main= 4) abline(lm(dist ~ speed, data = cars), col = &quot;red&quot;) Figure 6.11: A better-looking scatterplot with fitted regression line. This illustrates several of the additional commands. We have set the axis labels and the color of the plotting symbols. Next we added a main title and set the font to bold italic (try other values). Finally we set the best-fit line and made it red. 6.6.2 More useful commands We can alter the plotting symbol using the command pch=n, where n is a simple number. We can also alter the range of the x and y axes using xlim=c(lower, upper) and ylim=c(lower, upper). The size of the plotted points is manipulated using the cex=n command, where `n= the magnification’ factor. Here are some commands that illustrate these parameters: plot(dist ~ speed, data = cars, pch = 19, xlim = c(0,25), ylim = c(-20, 120), cex = 2) abline(lm(dist ~ speed, data = cars)) title(main = &quot;Scatterplot with altered y-axis and larger symbols&quot;) Figure 6.12: A scatterplot with fitted regression line and larger symbols. In Figure 6.12 the plotting symbol is set to 19 (a solid circle) and expanded by a factor of 2. Both x and y axes have been rescaled. The labels on the axes have been left blank and default to the name of the variable (which is taken from the data set). 6.6.3 An example with multiple symbols You have a data set called blood.txt which includes the variables Subject, Gender, AgeGroup, RBC (red blood cells), WBC (white blood cells) and Chol (Cholesterol). This data set has already been provided. Figure 6.13 shows a better-looking example with multiple symbols # Read the dataset blood &lt;- read.table(&quot;data/blood.txt&quot;, sep = &quot;&quot;, na.strings = &quot;.&quot;, colClasses = c(&quot;character&quot;, &quot;character&quot;, &quot;character&quot;, &quot;character&quot;, &quot;double&quot;, &quot;double&quot;, &quot;double&quot;),) # Assign the names to the above dataset names(blood) &lt;- c(&quot;Subject&quot;, &quot;Gender&quot;, &quot;BloodType&quot;, &quot;AgeGroup&quot;, &quot;WBC&quot;, &quot;RBC&quot;, &quot;Chol&quot;) # Draw a scatterplot plot(blood$WBC, blood$RBC, xlab = &quot;WBC&quot;, ylab = &quot;RBC&quot;, col = 1:4, pch = 1:4, ylim = c(2,9)) # Provide a legend legend(&quot;topleft&quot;, c(&quot;A&quot;, &quot;AB&quot;, &quot;B&quot;, &quot;O&quot;), pch = 1:4, col = 1:4) Figure 6.13: A scatterplot with multiple symbols and legend. Note: This function legend() can be used to add legends to plots. Look at help for details. 6.7 Line plots and Time series plots Previously we learned about bar charts (including histograms), pie charts, boxplots and scatter plots. However, there may be occasions when we wish to display data as a line, perhaps to show a time series. There is no specific line plot command in R so we must use other graph types and coerce the program to produce our line. 6.7.1 Plot types If we produce a plot we generally get a series of points. The default symbol for the points is an open circle but we can alter it using the pch=n parameter (see the section on scatter plots). Actually the points are only one sort of plot type that we can achieve in R (the default). We can use the parameter type = “type” to create other plots. Command Plot type type = &quot;p&quot; Produces points. type = &quot;l&quot; Produces line segments. type = &quot;b&quot; Produces points joined by line segments. type = &quot;o&quot; Similar to &quot;b&quot; but the points are overlaid onto the line. type = &quot;n&quot; Produces a graph with nothing it it! This can be used to create a graph frame that you add lines to later. So for example we may type: plot(x, y, type = \"b\") to produce a simple line plot with added points. 6.7.2 Time Series Consider the following data vostok, where we have mean monthly temperatures for an Antarctic research station. month temp 1 Jan -32.0 2 Feb -47.3 3 Mar -57.2 4 Apr -62.9 5 May -61.0 6 Jun -70.6 7 Jul -65.5 8 Aug -68.2 9 Sep -63.2 10 Oct -58.0 11 Nov -42.0 12 Dec -30.4 The file was read in using the standard read.table() command vostok = read.table(&quot;data/vostok.txt&quot;, header = TRUE, sep = &quot;\\t&quot;) so it contains two columns; month is a factor and temp is a numeric variable. If we attempt to plot the whole variable e.g. plot(temp ~ month) we get a horrid mess (try it and see). This is because the month is a factor and cannot be represented on an x, y scatter plot. However, if we plot the temperature alone we get the beginnings of something sensible: plot(vostok$temp) Figure 6.14: A plot the temperature alone. Figure 6.14 appears to be a series of points and they are in the correct order. We can easily join the dots to make a line plot by adding (type=\"b\") to the plot command (see the section on plot types). Notice how R have used default labels for the axes, temp for the y-axis is taken from the values in the variable but index is used for the x-axis because we have no reference (we only plotted a single variable). What we need to do next is to alter the x-axis to reflect our month variable. Custom axes When we look at the time series plot produced above we see that the x-axis needs a bit of work. Since the plot was made from a single variable (temp) there are no values for x and R substitutes a numeric index. We need to scrap the current axes and start again with our own. It is simple to produce a plot with no axes, merely add (axes=F) to the plot command; see 6.15 below. plot(vostok$temp, axes = F) Figure 6.15: A plot the temperature without of axes. However, R appends default labels to the axes so we need to get rid of those too: plot(vostok$temp, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;) Figure 6.16: A plot the temperature without of axes or labels. That does the job; see Figure 6.16. We are going to add axis labels of course so could have specified them now but I use the \"\" double (double) quotes to illustrate how to produce blank ones (setting xlab= F produces a label FALSE so we have to use \"\"). To add an axis we use the axis() command. Axis 1 is the bottom of the plot (i.e. the x-axis), axis 2 is the left side of the plot (the y-axis). We can also specify the top (3) and the right side (4) if we wish. In it’s simplest form axis(n) adds in the axis specified with it’s default parameters. This won’t do here because the default x-axis contains only index information. We need to tell R where to find the labels associated with the axis. To generate an axis we need to specify the length of it and the labels to be used. Figure 6.17 is what we need for our temperature example: plot(vostok$temp, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;) axis(1, at = 1:length(vostok$temp), labels = vostok$month) Figure 6.17: A plot of temperature. with time x-axis. Now we need to add in the y-axis and the axis labels. We could also add a title and perhaps the whole thing would look better if the dots were joined up to make a lineplot (which was after all the point of the exercise). Here is the whole series of commands from start to finish. Figure 6.18 shows the final time series plot. plot(vostok$temp, axes = F, xlab = &quot;&quot;, ylab = &quot;&quot;, type = &quot;b&quot;) axis(1, at = 1:length(vostok$temp), labels = vostok$month) axis(2) title(main = &quot;Time Series&quot;, font.main = 4, xlab = &quot;Month&quot;, ylab = &quot;Mean Temp C&quot;) box() #adds a border around the plot Figure 6.18: A time series plot of temperature. 6.8 Visualization using ggplot2 The package we will use to create visualizations is ggplot2. It allows for more sophisticated visualization as one progresses. ggplot2 allows for visualization using layers and addition of different commands that are useful in continuing to build and modify a visual representation. The typical syntax for creating a visualization specifies the dataset to be used, aesthetics of mapping that specifies the variable, and the type of chart such as barchart or a scatterplot etc to be used. 6.8.1 Scatter plots Simple scatterplots can be created using the R code below. The color, the size and the shape of points can be changed using the function geom_point() as follows: library(ggplot2) # Read the data blood &lt;- read.table(&quot;data/blood.txt&quot;, sep = &quot;&quot;, na.strings = &quot;.&quot;, colClasses = c(&quot;character&quot;,&quot;character&quot;, &quot;character&quot;,&quot;character&quot;, &quot;double&quot;,&quot;double&quot;,&quot;double&quot;),) # Assign the names to the above dataset names(blood) &lt;- c(&quot;Subject&quot;, &quot;Gender&quot;, &quot;BloodType&quot;, &quot;AgeGroup&quot;, &quot;WBC&quot;, &quot;RBC&quot;, &quot;Chol&quot;) blood$BloodType &lt;- as.factor(blood$BloodType) # Change point shapes by the levels of cyl ggplot(blood, aes(x = WBC, y = RBC, shape = BloodType)) + geom_point() ## Warning: Removed 167 rows containing missing values ## (geom_point). Figure 6.19: A scatterplot based on ggplot2. # Change point shapes and colors ggplot(blood, aes(x = WBC, y = RBC, shape = BloodType, color = BloodType)) + geom_point() ## Warning: Removed 167 rows containing missing values ## (geom_point). Figure 6.20: A scatterplot based on ggplot2. # Change point shapes, colors and size ggplot(blood, aes(x = WBC, y = RBC, shape = BloodType, color = BloodType, size = Chol)) + geom_point() ## Warning: Removed 337 rows containing missing values ## (geom_point). Figure 6.21: A scatterplot based on ggplot2. 6.8.2 Creating maps with ggplot2 We will learn how to make choropleth maps, sometimes called heat maps, using the ggplot2 package. A choropleth map is a map that shows a geographic landscape with units such as countries, states, or watersheds where each unit is colored according to a particular value. # Read map and data library(ggplot2) library(maps) # load United States state map data MainStates &lt;- map_data(&quot;state&quot;) # read the state population data StatePopulation &lt;- read.csv(&quot;https://raw.githubusercontent.com/ds4stats/r-tutorials/master/intro-maps/data/StatePopulation.csv&quot;, as.is = TRUE) Your first map qplot(long, lat, geom = &quot;point&quot;, data = MainStates) Figure 6.22: Your first map. Making a base map #plot all states with ggplot2, using black borders and light blue fill ggplot() + geom_polygon(data = MainStates, aes(x = long, y = lat, group = group), color = &quot;black&quot;, fill = &quot;lightblue&quot;) Figure 6.23: A base map. Customizing your choropleth map Now that we have created a base map of the mainland states, we will color each state according to its population. The first step is to use the dplyr package to merge the MainStates and StatePopulation files. # Use the dplyr package to merge MainStates and StatePopulation library(dplyr) MergedStates &lt;- inner_join(MainStates, StatePopulation, by = &quot;region&quot;) # Create a Choropleth map of the United States p &lt;- ggplot() p &lt;- p + geom_polygon(data = MergedStates, aes(x = long, y = lat, group = group, fill = population/1000000), color = &quot;white&quot;, size = 0.2) p Figure 6.24: A customized choropleth map. Remarks Instead of using population, we use population/1000000. Each state is colored by population size (in millions) to make the legend easier to read. Border color (white) and line thickness (0.2) are specifically defined within this geom. Once a map is created, it is often helpful to modify color schemes, determine how to address missing values (na.values) and formalize labels. Notice that we assigned the graph a name, p. This is particularly useful as we add new components to the graph. p &lt;- p + scale_fill_continuous(name = &quot;Population(millions)&quot;, low = &quot;lightgreen&quot;, high = &quot;darkgreen&quot;, limits = c(0,40), breaks = c(5,10,15,20,25,30,35), na.value = &quot;grey50&quot;) + labs(title = &quot;State Population in the Mainland United States&quot;) p Figure 6.25: A customized choropleth map filled in with green coloor. It is also possible to overlay two polygon maps. The code below creates county borders with a small line size and then adds a thicker line to represent state borders. The alpha = .3 causes the fill in the state map to be transparent, allowing us to see the county map behind the state map. AllCounty &lt;- map_data(&quot;county&quot;) ggplot() + geom_polygon(data=AllCounty, aes(x = long, y = lat, group = group), color = &quot;darkblue&quot;, fill = &quot;lightblue&quot;, size = .1 ) + geom_polygon(data = MainStates, aes(x = long, y = lat, group = group), color = &quot;black&quot;, fill = &quot;lightblue&quot;, size = 1, alpha = .3) Figure 6.26: A county map. 6.9 Exercises Plot the sine(x) and cos(x) curves on the same plot, where \\(x\\in[-\\pi,\\pi]\\). For the sine curve use a line and for the cosine curve use points. Read in the data from the file ozone.txt. It contains 78 measurements of ozone concentration in the downtown Los Angeles atmosphere during the summers of 1966 and 1967. Find the minimum and maximum of ozone data; Draw a histogram for the data; Draw a boxplot for the data; Draw a stem-and-leaf chart for the data. A medical researcher wishes to determine if a pill has the undesirable side effect of reducing the blood pressure of the user. The study involves recording the initial blood pressures of 15 college-age women. After they use the pill regularly for six months, their blood pressures are again recorded. The researcher wishes to draw inferences about the effect of the pill on blood pressure from the observations given in the following: Blood-pressure Measurements Before and After Use of Pill -------------------------------------------------------- Subject 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 -------------------------------------------------------- Before(x) 70 80 72 76 76 76 72 78 82 64 74 92 74 68 84 After(y) 68 72 62 70 58 66 68 52 64 72 74 60 74 72 74 -------------------------------------------------------- Draw a scatter plot. Make the x-axis represent the “Before” measurements, and y-axis represent “After” measurements. Do the following for the data(mpg). Run ggplot(data = mpg). What do you see? How many rows are in mpg? How many columns? What does the drv variable describe? Read the help for ?mpg to find out. Make a scatterplot of hwy vs cyl. What happens if you make a scatterplot of class vs drv? Why is the plot not useful? "],
["r-markdown.html", "Chapter 7 R Markdown 7.1 Getting Started with R Markdown 7.2 Formatting Your Document 7.3 Text Formatting 7.4 Greek Alphabet 7.5 R code chunks and inline R code 7.6 Including Plots and Adding Captions 7.7 Modifying Figures 7.8 Displaying Data with kable 7.9 Compiling R Markdown Documents", " Chapter 7 R Markdown R Markdown is a convenient feature of RStudio that allows you to keep your R code, results, and commentary in one file. R Markdown (.Rmd) is an authoring format that enables easy creation of dynamic documents, presentations, and reports from R. It combines the core syntax of markdown (an easy to write plain text format) with embedded R code chunks that are run so their output can be included in the final document. R Markdown documents are fully reproducible (they can be automatically regenerated whenever underlying R code or data changes).” – RStudio documentation. R Markdown has 3 main purposes: To communicate results to people who are more interested in your conclusions than how your reached them; To collaborate with other statisticians who are interested in both your code and your results; To function somewhat like a lab notebook: you can include your code and the reasoning behind it so you can easily understand and share what you did. R Markdown documents are fully reproducible and support dozens of static and dynamic output formats. Three of the most common formats are: HTML PDF Word documents If you prefer a video introduction to R Markdown, we recommend that you check out the website https://rmarkdown.rstudio.com, and watch the videos in the “Get Started” section, which cover the basics of R Markdown. In this chapter, we provide a very basic introduction of R Markdow. RStudio has created an R Markdown cheat sheet, which are freely available at https://www.rstudio.com/resources/cheatsheets/. More details of R Markdown can be found from https://bookdown.org/yihui/rmarkdown/. Installation Like the rest of R, R Markdown is free and open source. You can install the R Markdown package from CRAN with: install.packages(&quot;rmarkdown&quot;) To produce PDF documents, you will also need to install * MiKTex: https://miktex.org/download (Windows users) * MacTeX: https://www.tug.org/mactex/mactex-download.html (Mac users) 7.1 Getting Started with R Markdown Open RStudio. At the top of the screen, click on “File”, “New File”, “R Markdown”. This will bring up a dialog box that looks something like the image on the right (Mac version). You can enter a title for your document and enter your name in the “Author” field. Next, you need to choose your output format. HTML is the default, though you can also choose PDF or a Word document. After you click OK, the R Markdown workspace will be generated. 7.2 Formatting Your Document At the top of a default R Markdown document, you will see something that looks like this: --- title: &quot;Untitled&quot; author: &quot;Your Name&quot; date: &quot;12/12/2020&quot; output: pdf_document --- This is called the YAML header. We can include more options to further customize our document. YAML Header Options The geometry option lets you change the margins of your document. The fontsize option changes the font size in your document. Specifying pagenumber: TRUE adds page numbers to your document. If you would like to use the report format that generates a convenient title page, include documentclass: report. You may find the report document class useful when creating your report. The report format automatically makes a title page for your document. You will need to format your headers like this: ##Header. Otherwise, your headers will be preceded by “Chapter 1” and so on. This is how to use the report template in your document: --- title: &quot;Untitled&quot; author: &quot;Your Name&quot; date: &quot;12/12/2020&quot; output: pdf_document pagenumber: TRUE geometry: margin=1in fontsize: 12pt documentclass: report --- 7.3 Text Formatting In R Markdown, you can type regular text without having to make everything a comment. Usually, LaTeX commands will work. To make a new line, put 2 spaces at the end of the line before and then start the new line. To italicize text, use italics or italics. To make text bold, use bold or bold. To make a superscript, use x^2^ for normal text or \\(x^2\\) to make a subscript for an equation. To make a subscript, use x~0~ for normal text or \\(x_0\\) to make a subscript for an equation. 7.4 Greek Alphabet Many statistical expressions use the Greek alphabet, so it is good to know how to use Greek letters in R Markdown. This is alpha: \\(\\alpha\\) This is beta: \\(\\beta\\) This is epsilon: \\(\\epsilon\\) This is the equation for the univariate linear regression model: \\(y_i = \\beta_0 + \\beta_1x_i + \\epsilon_i\\). This is the prediction equation for y based on \\(x_i\\): \\(\\hat{y_i} = \\hat{\\beta_0} + \\hat{\\beta_1}x_i\\). 7.5 R code chunks and inline R code There are a lot of things you can do in a code chunk: you can produce text output, tables, or graphics. You have fine control over all these output via chunk options, which can be provided inside the curly braces. For example, you can choose hide text output via the chunk option results = 'hide', or set the figure height to 4 inches via fig.height = 4. Chunk options are separated by commas, e.g., {r, chunk-label, results=&#39;hide&#39;, fig.height=4} There are a large number of chunk options in knitr documented at https://yihui.name/knitr/options. We list a subset of them below: eval: Whether to evaluate a code chunk. echo: Whether to echo the source code in the output document (someone may not prefer reading your smart source code but only results). results: When set to 'hide', text output will be hidden; when set to 'asis', text output is written “as-is,”. warning, message, and error: Whether to show warnings, messages, and errors in the output document. Note that if you set error = FALSE, rmarkdown::render() will halt on error in a code chunk, and the error will be displayed in the R console. Similarly, when warning = FALSE or message = FALSE, these messages will be shown in the R console. Rendering Output There are two ways to render an R Markdown document into its final output format. If you are using RStudio, then the “Knit” button (Ctrl+Shift+K) will render the document and display a preview of it. If you are not using RStudio then you simply need to call the rmarkdown::render function, for example: rmarkdown::render(&quot;input.Rmd&quot;) 7.6 Including Plots and Adding Captions You can embed plots and add captions. Figure 7.1 shows a plot of the built-in trees dataset. Figure 7.1: An example of a simple plot. 7.7 Modifying Figures What if we would like to change the size of the plot? The fig.height option lets us specify how tall we want the plot to be, the fig.width option lets us specify how wide we want the plot to be, and the fig.align option lets us specify whether we want the plot to be left-aligned, centered, or right-aligned. An example is shown in Figure 7.2. plot(trees$Height, trees$volume) Figure 7.2: A smaller version of the plot. 7.8 Displaying Data with kable You can make nice-looking tables that are not in plain text with kable. Compare the kable to the plain-text version of the data. kable(pressure, caption = &quot;A kable of the built-in pressure dataset&quot;) Table 7.1: A kable of the built-in pressure dataset temperature pressure 0 0.0002 20 0.0012 40 0.0060 60 0.0300 80 0.0900 100 0.2700 120 0.7500 140 1.8500 160 4.2000 180 8.8000 200 17.3000 220 32.1000 240 57.0000 260 96.0000 280 157.0000 300 247.0000 320 376.0000 340 558.0000 360 806.0000 pressure ## temperature pressure ## 1 0 0.0002 ## 2 20 0.0012 ## 3 40 0.0060 ## 4 60 0.0300 ## 5 80 0.0900 ## 6 100 0.2700 ## 7 120 0.7500 ## 8 140 1.8500 ## 9 160 4.2000 ## 10 180 8.8000 ## 11 200 17.3000 ## 12 220 32.1000 ## 13 240 57.0000 ## 14 260 96.0000 ## 15 280 157.0000 ## 16 300 247.0000 ## 17 320 376.0000 ## 18 340 558.0000 ## 19 360 806.0000 7.9 Compiling R Markdown Documents When you want to see what your compiled R Markdown document looks like, click on the ball of yarn at the top of the workspace to “knit” or compile the document. You can see the progress as your document is knitted in the “R Markdown” tab in the Console window at the bottom of the screen. If there is a problem, the knitting process will stop and an error message will appear in the R Markdown Console window. The error message tells you the line where the first error occurred so you can go back and fix it. Once the error is fixed, try knitting the document again. The process continues until the document is error-free and the output file can be produced. "],
["data-wrangling-with-dplyr-and-tidyr.html", "Chapter 8 Data Wrangling with dplyr and tidyr 8.1 Learning dplyr 8.2 Selecting columns and filtering rows 8.3 Pipes 8.4 Select and order top n entries (by group if grouped data). 8.5 Mutate 8.6 Split-apply-combine data analysis and the summarize() function 8.7 Joins with dplyr 8.8 Reshaping Data - Change the layout of a data set 8.9 Exercises", " Chapter 8 Data Wrangling with dplyr and tidyr The package dplyr is an R package for making tabular data wrangling easier by using a limited set of functions that can be combined to extract and summarize insights from your data. It pairs nicely with the package tidyr, enabling you to swiftly convert between different data formats (long vs. wide) for plotting and analysis. dplyr is built to work directly with dataframes, with many common tasks optimized by being written in a compiled language (C++) (not all R packages are written in R!). The package tidyr addresses the common problem of reshaping your data for plotting and use by different R functions. Sometimes we want data sets where we have one row per measurement. Sometimes we want a dataframe where each measurement type has its own column, and rows are instead more aggregated groups. Moving back and forth between these formats is nontrivial, and tidyr gives you tools for this and more sophisticated data wrangling. 8.1 Learning dplyr # Load the tidyverse library(tidyverse) library(dplyr) Below we will work on COVID-19 county level infected count data, and we can obtain the data from Github R package slid. # Install the slid package from github # library(devtools) # devtools::install_github(&#39;covid19-dashboard-us/slid&#39;) # Load objects in I.county into my workspace library(slid) data(I.county) # preview the data # View(I.county) We’re going to learn some of the most common dplyr functions: select(): subset columns filter(): subset rows on conditions mutate(): create new columns by using information from other columns group_by() and summarize(): create summary statistics on grouped data arrange(): sort results count(): count discrete values 8.2 Selecting columns and filtering rows To select columns of a dataframe, use select(). The first argument to this function is the dataframe (I.county), and the subsequent arguments are the columns to keep, separated by commas. Alternatively, if you are selecting columns adjacent to each other, you can use a : to select a range of columns, read as “select columns from __ to __.” # load the tidyverse dplyr::select(I.county, ID, County, State) # to select a series of connected columns dplyr::select(I.county, ID, County, State, X2020.12.11:X2020.12.01) To choose rows based on specific criteria, we can use the filter() function. The arguments after the dataframe are the condition(s) we want for our final dataframe to adhere to (e.g. State name is “Iowa”). We can chain a series of conditions together using commas between each condition. # all Iowa counties dplyr::filter(I.county, State == &quot;Iowa&quot;) Here is an example of filter() function with multiple conditions: # multiple conditions: all Iowa counties with cumulative # infection count &gt; 10000 dplyr::filter(I.county, State == &quot;Iowa&quot;, X2020.12.11 &gt; 10000) Figure 8.1 shows some commonly used R logic omparisons Figure 8.1: Some commonly used logic comparisons. 8.3 Pipes What if you want to select and filter at the same time? There are three ways to do this: use intermediate steps, nested functions, or pipes. With intermediate steps, you create a temporary dataframe and use that as input to the next function, like this: Iowa.I.county &lt;- dplyr::filter(I.county, State == &quot;Iowa&quot;) Iowa.I.county.DEC &lt;- dplyr::select(Iowa.I.county, X2020.12.11:X2020.12.01) This is readable, but can clutter up your workspace with lots of objects that you have to name individually. With multiple steps, that can be hard to keep track of. You can also nest functions (i.e. one function inside of another), like this: Iowa.I.county.DEC &lt;- dplyr::select(dplyr::filter(I.county, State == &quot;Iowa&quot;), ID, County, State, X2020.12.11:X2020.12.01) This is handy but can be difficult to read if too many functions are nested, as R evaluates the expression from the inside out (in this case, filtering, then selecting). The last option, pipes, are a recent addition to R. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset. Pipes in R look like %&gt;% and are made available via the magrittr package, installed automatically with dplyr. I.county %&gt;% dplyr::filter(State == &quot;Iowa&quot;) %&gt;% dplyr::select(ID, County, X2020.12.11:X2020.12.01) In the above code, we use the pipe to send the interviews dataset first through filter() to keep rows for the state of Iowa, then through select() to keep only the count in December. Since %&gt;% takes the object on its left and passes it as the first argument to the function on its right, we don’t need to explicitly include the dataframe as an argument to the filter() and select() functions anymore. Some may find it helpful to read the pipe like the word “then”. For instance, in the above example, we take the dataframe I.county, then we filter for rows with State == \"Iowa\", then we select columns from X2020.12.11 to X2020.12.01. The dplyr functions are somewhat simple, but by combining them into linear workflows with the pipe, we can accomplish more complex data wrangling operations. If we want to create a new object with this smaller version of the data, we can assign it a new name: Iowa.I.county.DEC &lt;- I.county %&gt;% dplyr::filter(State == &quot;Iowa&quot;) %&gt;% dplyr::select(ID, County, X2020.12.11:X2020.12.01) head(Iowa.I.county.DEC) ## ID County X2020.12.11 X2020.12.10 X2020.12.09 ## 1 19001 Adair 506 503 499 ## 2 19003 Adams 208 206 200 ## 3 19005 Allamakee 995 990 971 ## 4 19007 Appanoose 868 862 858 ## 5 19009 Audubon 326 323 321 ## 6 19011 Benton 1852 1847 1826 ## X2020.12.08 X2020.12.07 X2020.12.06 X2020.12.05 ## 1 489 484 484 479 ## 2 196 196 195 193 ## 3 954 939 925 922 ## 4 853 849 843 839 ## 5 315 314 313 312 ## 6 1819 1798 1789 1778 ## X2020.12.04 X2020.12.03 X2020.12.02 X2020.12.01 ## 1 472 453 448 444 ## 2 188 181 179 171 ## 3 912 884 870 850 ## 4 834 816 807 804 ## 5 312 311 305 301 ## 6 1769 1754 1740 1728 8.4 Select and order top n entries (by group if grouped data). The function top_n can be used to select top (or bottom) n rows (by value). This is a convenient wrapper that uses filter()and min_rank() to select the top or bottom entries in each group, ordered by wt. ** Usage ** top_n(x, n, wt) ** Arguments ** * x: a tbl() to filter * n: number of rows to return. If x is grouped, this is the number of rows per group. Will include more than n rows if there are ties. If n is positive, selects the top n rows. If negative, selects the bottom n rows. * wt (Optional). The variable to use for ordering. If not specified, defaults to the last variable in the tbl. This argument is automatically quoted and later evaluated in the context of the data frame. It supports unquoting. Let us find the top ten counties with the largest cumulative infected count on December 11, 2020. library(dplyr) I.county.top10 &lt;- I.county %&gt;% top_n(10, wt = X2020.12.11) I.county.top10$County ## [1] Maricopa LosAngeles SanBernardino Broward ## [5] Miami-Dade Cook Clark Dallas ## [9] Harris Tarrant ## 1839 Levels: Abbeville AcadiaParish Accomack Ada ... obrien Let us find the top ten counties with the smallest cumulative infected count on December 11, 2020. library(dplyr) I.county.bottom10 &lt;- I.county %&gt;% top_n(-10, wt = X2020.12.11) I.county.bottom10$County ## [1] Dukes Nantucket OglalaLakota Beaver ## [5] BoxElder Cache Carbon Daggett ## [9] Duchesne Emery Garfield Grand ## [13] Iron Juab Kane Millard ## [17] Morgan Piute Rich Sanpete ## [21] Sevier Uintah Washington Wayne ## [25] Weber ## 1839 Levels: Abbeville AcadiaParish Accomack Ada ... obrien Let us find the county with the largest cumulative infected count on December 11, 2020 for each state. library(dplyr) I.county.top1 &lt;- I.county %&gt;% group_by(State) %&gt;% top_n(1, wt = X2020.12.11) %&gt;% dplyr::select(State, County) 8.5 Mutate Frequently you’ll want to create new columns based on the values in existing columns, for example, to obtain the number of daily new cases based on the cumulative count. For this, we’ll use mutate(). I.county.new &lt;- I.county %&gt;% dplyr::filter(State == &quot;Iowa&quot;) %&gt;% dplyr::select(ID, County, X2020.12.11:X2020.12.10) %&gt;% mutate(Y2020.12.11 = X2020.12.11 - X2020.12.10) head(I.county.new) ## ID County X2020.12.11 X2020.12.10 Y2020.12.11 ## 1 19001 Adair 506 503 3 ## 2 19003 Adams 208 206 2 ## 3 19005 Allamakee 995 990 5 ## 4 19007 Appanoose 868 862 6 ## 5 19009 Audubon 326 323 3 ## 6 19011 Benton 1852 1847 5 If we want to obtain the number of daily new cases based on the cumulative count for the dates in December only, we can try the following: I.county.Iowa &lt;- I.county %&gt;% dplyr::filter(State == &quot;Iowa&quot;) I.county.tmp = I.county.Iowa[, -(1:3)] I.county.Iowa.new = I.county.Iowa I.county.Iowa.new[, -(1:3)] = I.county.tmp - cbind(I.county.tmp[, -1], 0) I.county.Iowa.DEC = I.county.Iowa.new %&gt;% dplyr::select(ID, County, X2020.12.11:X2020.12.01) name.tmp = substring(names(I.county.Iowa.DEC)[-(1:2)], 2) names(I.county.Iowa.DEC)[-(1:2)] = paste0(&quot;Y&quot;, name.tmp) head(I.county.Iowa.DEC) ## ID County Y2020.12.11 Y2020.12.10 Y2020.12.09 ## 1 19001 Adair 3 4 10 ## 2 19003 Adams 2 6 4 ## 3 19005 Allamakee 5 19 17 ## 4 19007 Appanoose 6 4 5 ## 5 19009 Audubon 3 2 6 ## 6 19011 Benton 5 21 7 ## Y2020.12.08 Y2020.12.07 Y2020.12.06 Y2020.12.05 ## 1 5 0 5 7 ## 2 0 1 2 5 ## 3 15 14 3 10 ## 4 4 6 4 5 ## 5 1 1 1 0 ## 6 21 9 11 9 ## Y2020.12.04 Y2020.12.03 Y2020.12.02 Y2020.12.01 ## 1 19 5 4 3 ## 2 7 2 8 0 ## 3 28 14 20 22 ## 4 18 9 3 5 ## 5 1 6 4 1 ## 6 15 14 12 10 8.6 Split-apply-combine data analysis and the summarize() function Many data analysis tasks can be approached using the split-apply-combine paradigm: split the data into groups, apply some analysis to each group, and then combine the results. dplyr makes this very easy via the group_by() function. The summarize() function Summarize uses summary functions, functions that take a vector of values and return a single value, such as: dplyr::first: First value of a vector. dplyr::last: Last value of a vector. dplyr::nth: Nth value of a vector. dplyr::n: # of values in a vector. dplyr::n_distinct: # of distinct values in a vector. IQR: IQR of a vector. min: Minimum value in a vector. max: Maximum value in a vector. mean: Mean value of a vector. median: Median value of a vector. var: Variance of a vector. sd: Standard deviation of a vector. group_by() is often used together with summarize(), which collapses each group into a single-row summary of that group. group_by() takes as arguments the column names that contain the categorical variables for which you want to calculate the summary statistics. Once the data are grouped, you can also summarize multiple variables simultaneously (and not necessarily on the same variable). So to compute the state level infected count by State: I.state &lt;- I.county %&gt;% group_by(State) %&gt;% summarize(across(X2020.12.11:X2020.01.22, ~ sum(.x, na.rm = TRUE))) ## `summarise()` ungrouping output (override with `.groups` argument) head(I.state, 2) ## # A tibble: 2 x 326 ## State X2020.12.11 X2020.12.10 X2020.12.09 X2020.12.08 ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Alab… 288775 284922 280187 276665 ## 2 Ariz… 394512 387529 382601 378157 ## # … with 321 more variables: X2020.12.07 &lt;int&gt;, ## # X2020.12.06 &lt;int&gt;, X2020.12.05 &lt;int&gt;, ## # X2020.12.04 &lt;int&gt;, X2020.12.03 &lt;int&gt;, ## # X2020.12.02 &lt;int&gt;, X2020.12.01 &lt;int&gt;, ## # X2020.11.30 &lt;int&gt;, X2020.11.29 &lt;int&gt;, ## # X2020.11.28 &lt;int&gt;, X2020.11.27 &lt;int&gt;, ## # X2020.11.26 &lt;int&gt;, X2020.11.25 &lt;int&gt;, ## # X2020.11.24 &lt;int&gt;, X2020.11.23 &lt;int&gt;, ## # X2020.11.22 &lt;int&gt;, X2020.11.21 &lt;int&gt;, ## # X2020.11.20 &lt;int&gt;, X2020.11.19 &lt;int&gt;, ## # X2020.11.18 &lt;int&gt;, X2020.11.17 &lt;int&gt;, ## # X2020.11.16 &lt;int&gt;, X2020.11.15 &lt;int&gt;, ## # X2020.11.14 &lt;int&gt;, X2020.11.13 &lt;int&gt;, ## # X2020.11.12 &lt;int&gt;, X2020.11.11 &lt;int&gt;, ## # X2020.11.10 &lt;int&gt;, X2020.11.09 &lt;int&gt;, ## # X2020.11.08 &lt;int&gt;, X2020.11.07 &lt;int&gt;, ## # X2020.11.06 &lt;int&gt;, X2020.11.05 &lt;int&gt;, ## # X2020.11.04 &lt;int&gt;, X2020.11.03 &lt;int&gt;, ## # X2020.11.02 &lt;int&gt;, X2020.11.01 &lt;int&gt;, ## # X2020.10.31 &lt;int&gt;, X2020.10.30 &lt;int&gt;, ## # X2020.10.29 &lt;int&gt;, X2020.10.28 &lt;int&gt;, ## # X2020.10.27 &lt;int&gt;, X2020.10.26 &lt;int&gt;, ## # X2020.10.25 &lt;int&gt;, X2020.10.24 &lt;int&gt;, ## # X2020.10.23 &lt;int&gt;, X2020.10.22 &lt;int&gt;, ## # X2020.10.21 &lt;int&gt;, X2020.10.20 &lt;int&gt;, ## # X2020.10.19 &lt;int&gt;, X2020.10.18 &lt;int&gt;, ## # X2020.10.17 &lt;int&gt;, X2020.10.16 &lt;int&gt;, ## # X2020.10.15 &lt;int&gt;, X2020.10.14 &lt;int&gt;, ## # X2020.10.13 &lt;int&gt;, X2020.10.12 &lt;int&gt;, ## # X2020.10.11 &lt;int&gt;, X2020.10.10 &lt;int&gt;, ## # X2020.10.09 &lt;int&gt;, X2020.10.08 &lt;int&gt;, ## # X2020.10.07 &lt;int&gt;, X2020.10.06 &lt;int&gt;, ## # X2020.10.05 &lt;int&gt;, X2020.10.04 &lt;int&gt;, ## # X2020.10.03 &lt;int&gt;, X2020.10.02 &lt;int&gt;, ## # X2020.10.01 &lt;int&gt;, X2020.09.30 &lt;int&gt;, ## # X2020.09.29 &lt;int&gt;, X2020.09.28 &lt;int&gt;, ## # X2020.09.27 &lt;int&gt;, X2020.09.26 &lt;int&gt;, ## # X2020.09.25 &lt;int&gt;, X2020.09.24 &lt;int&gt;, ## # X2020.09.23 &lt;int&gt;, X2020.09.22 &lt;int&gt;, ## # X2020.09.21 &lt;int&gt;, X2020.09.20 &lt;int&gt;, ## # X2020.09.19 &lt;int&gt;, X2020.09.18 &lt;int&gt;, ## # X2020.09.17 &lt;int&gt;, X2020.09.16 &lt;int&gt;, ## # X2020.09.15 &lt;int&gt;, X2020.09.14 &lt;int&gt;, ## # X2020.09.13 &lt;int&gt;, X2020.09.12 &lt;int&gt;, ## # X2020.09.11 &lt;int&gt;, X2020.09.10 &lt;int&gt;, ## # X2020.09.09 &lt;int&gt;, X2020.09.08 &lt;int&gt;, ## # X2020.09.07 &lt;int&gt;, X2020.09.06 &lt;int&gt;, ## # X2020.09.05 &lt;int&gt;, X2020.09.04 &lt;int&gt;, ## # X2020.09.03 &lt;int&gt;, X2020.09.02 &lt;int&gt;, ## # X2020.09.01 &lt;int&gt;, X2020.08.31 &lt;int&gt;, ## # X2020.08.30 &lt;int&gt;, … or we can use summarise_at(), which affects variables selected with a character vector or vars(): I.state &lt;- I.county %&gt;% group_by(State) %&gt;% summarize_at(vars(X2020.12.11:X2020.01.22), ~ sum(.x, na.rm = TRUE)) head(I.state, 2) ## # A tibble: 2 x 326 ## State X2020.12.11 X2020.12.10 X2020.12.09 X2020.12.08 ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Alab… 288775 284922 280187 276665 ## 2 Ariz… 394512 387529 382601 378157 ## # … with 321 more variables: X2020.12.07 &lt;int&gt;, ## # X2020.12.06 &lt;int&gt;, X2020.12.05 &lt;int&gt;, ## # X2020.12.04 &lt;int&gt;, X2020.12.03 &lt;int&gt;, ## # X2020.12.02 &lt;int&gt;, X2020.12.01 &lt;int&gt;, ## # X2020.11.30 &lt;int&gt;, X2020.11.29 &lt;int&gt;, ## # X2020.11.28 &lt;int&gt;, X2020.11.27 &lt;int&gt;, ## # X2020.11.26 &lt;int&gt;, X2020.11.25 &lt;int&gt;, ## # X2020.11.24 &lt;int&gt;, X2020.11.23 &lt;int&gt;, ## # X2020.11.22 &lt;int&gt;, X2020.11.21 &lt;int&gt;, ## # X2020.11.20 &lt;int&gt;, X2020.11.19 &lt;int&gt;, ## # X2020.11.18 &lt;int&gt;, X2020.11.17 &lt;int&gt;, ## # X2020.11.16 &lt;int&gt;, X2020.11.15 &lt;int&gt;, ## # X2020.11.14 &lt;int&gt;, X2020.11.13 &lt;int&gt;, ## # X2020.11.12 &lt;int&gt;, X2020.11.11 &lt;int&gt;, ## # X2020.11.10 &lt;int&gt;, X2020.11.09 &lt;int&gt;, ## # X2020.11.08 &lt;int&gt;, X2020.11.07 &lt;int&gt;, ## # X2020.11.06 &lt;int&gt;, X2020.11.05 &lt;int&gt;, ## # X2020.11.04 &lt;int&gt;, X2020.11.03 &lt;int&gt;, ## # X2020.11.02 &lt;int&gt;, X2020.11.01 &lt;int&gt;, ## # X2020.10.31 &lt;int&gt;, X2020.10.30 &lt;int&gt;, ## # X2020.10.29 &lt;int&gt;, X2020.10.28 &lt;int&gt;, ## # X2020.10.27 &lt;int&gt;, X2020.10.26 &lt;int&gt;, ## # X2020.10.25 &lt;int&gt;, X2020.10.24 &lt;int&gt;, ## # X2020.10.23 &lt;int&gt;, X2020.10.22 &lt;int&gt;, ## # X2020.10.21 &lt;int&gt;, X2020.10.20 &lt;int&gt;, ## # X2020.10.19 &lt;int&gt;, X2020.10.18 &lt;int&gt;, ## # X2020.10.17 &lt;int&gt;, X2020.10.16 &lt;int&gt;, ## # X2020.10.15 &lt;int&gt;, X2020.10.14 &lt;int&gt;, ## # X2020.10.13 &lt;int&gt;, X2020.10.12 &lt;int&gt;, ## # X2020.10.11 &lt;int&gt;, X2020.10.10 &lt;int&gt;, ## # X2020.10.09 &lt;int&gt;, X2020.10.08 &lt;int&gt;, ## # X2020.10.07 &lt;int&gt;, X2020.10.06 &lt;int&gt;, ## # X2020.10.05 &lt;int&gt;, X2020.10.04 &lt;int&gt;, ## # X2020.10.03 &lt;int&gt;, X2020.10.02 &lt;int&gt;, ## # X2020.10.01 &lt;int&gt;, X2020.09.30 &lt;int&gt;, ## # X2020.09.29 &lt;int&gt;, X2020.09.28 &lt;int&gt;, ## # X2020.09.27 &lt;int&gt;, X2020.09.26 &lt;int&gt;, ## # X2020.09.25 &lt;int&gt;, X2020.09.24 &lt;int&gt;, ## # X2020.09.23 &lt;int&gt;, X2020.09.22 &lt;int&gt;, ## # X2020.09.21 &lt;int&gt;, X2020.09.20 &lt;int&gt;, ## # X2020.09.19 &lt;int&gt;, X2020.09.18 &lt;int&gt;, ## # X2020.09.17 &lt;int&gt;, X2020.09.16 &lt;int&gt;, ## # X2020.09.15 &lt;int&gt;, X2020.09.14 &lt;int&gt;, ## # X2020.09.13 &lt;int&gt;, X2020.09.12 &lt;int&gt;, ## # X2020.09.11 &lt;int&gt;, X2020.09.10 &lt;int&gt;, ## # X2020.09.09 &lt;int&gt;, X2020.09.08 &lt;int&gt;, ## # X2020.09.07 &lt;int&gt;, X2020.09.06 &lt;int&gt;, ## # X2020.09.05 &lt;int&gt;, X2020.09.04 &lt;int&gt;, ## # X2020.09.03 &lt;int&gt;, X2020.09.02 &lt;int&gt;, ## # X2020.09.01 &lt;int&gt;, X2020.08.31 &lt;int&gt;, ## # X2020.08.30 &lt;int&gt;, … or we can use summarise_if(), which affects variables selected with a predicate function: I.state &lt;- I.county %&gt;% group_by(State) %&gt;% summarize_if(is.numeric, ~ sum(.x, na.rm = TRUE)) head(I.state, 2) ## # A tibble: 2 x 327 ## State ID X2020.12.11 X2020.12.10 X2020.12.09 ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Alab… 71489 288775 284922 280187 ## 2 Ariz… 60208 394512 387529 382601 ## # … with 322 more variables: X2020.12.08 &lt;int&gt;, ## # X2020.12.07 &lt;int&gt;, X2020.12.06 &lt;int&gt;, ## # X2020.12.05 &lt;int&gt;, X2020.12.04 &lt;int&gt;, ## # X2020.12.03 &lt;int&gt;, X2020.12.02 &lt;int&gt;, ## # X2020.12.01 &lt;int&gt;, X2020.11.30 &lt;int&gt;, ## # X2020.11.29 &lt;int&gt;, X2020.11.28 &lt;int&gt;, ## # X2020.11.27 &lt;int&gt;, X2020.11.26 &lt;int&gt;, ## # X2020.11.25 &lt;int&gt;, X2020.11.24 &lt;int&gt;, ## # X2020.11.23 &lt;int&gt;, X2020.11.22 &lt;int&gt;, ## # X2020.11.21 &lt;int&gt;, X2020.11.20 &lt;int&gt;, ## # X2020.11.19 &lt;int&gt;, X2020.11.18 &lt;int&gt;, ## # X2020.11.17 &lt;int&gt;, X2020.11.16 &lt;int&gt;, ## # X2020.11.15 &lt;int&gt;, X2020.11.14 &lt;int&gt;, ## # X2020.11.13 &lt;int&gt;, X2020.11.12 &lt;int&gt;, ## # X2020.11.11 &lt;int&gt;, X2020.11.10 &lt;int&gt;, ## # X2020.11.09 &lt;int&gt;, X2020.11.08 &lt;int&gt;, ## # X2020.11.07 &lt;int&gt;, X2020.11.06 &lt;int&gt;, ## # X2020.11.05 &lt;int&gt;, X2020.11.04 &lt;int&gt;, ## # X2020.11.03 &lt;int&gt;, X2020.11.02 &lt;int&gt;, ## # X2020.11.01 &lt;int&gt;, X2020.10.31 &lt;int&gt;, ## # X2020.10.30 &lt;int&gt;, X2020.10.29 &lt;int&gt;, ## # X2020.10.28 &lt;int&gt;, X2020.10.27 &lt;int&gt;, ## # X2020.10.26 &lt;int&gt;, X2020.10.25 &lt;int&gt;, ## # X2020.10.24 &lt;int&gt;, X2020.10.23 &lt;int&gt;, ## # X2020.10.22 &lt;int&gt;, X2020.10.21 &lt;int&gt;, ## # X2020.10.20 &lt;int&gt;, X2020.10.19 &lt;int&gt;, ## # X2020.10.18 &lt;int&gt;, X2020.10.17 &lt;int&gt;, ## # X2020.10.16 &lt;int&gt;, X2020.10.15 &lt;int&gt;, ## # X2020.10.14 &lt;int&gt;, X2020.10.13 &lt;int&gt;, ## # X2020.10.12 &lt;int&gt;, X2020.10.11 &lt;int&gt;, ## # X2020.10.10 &lt;int&gt;, X2020.10.09 &lt;int&gt;, ## # X2020.10.08 &lt;int&gt;, X2020.10.07 &lt;int&gt;, ## # X2020.10.06 &lt;int&gt;, X2020.10.05 &lt;int&gt;, ## # X2020.10.04 &lt;int&gt;, X2020.10.03 &lt;int&gt;, ## # X2020.10.02 &lt;int&gt;, X2020.10.01 &lt;int&gt;, ## # X2020.09.30 &lt;int&gt;, X2020.09.29 &lt;int&gt;, ## # X2020.09.28 &lt;int&gt;, X2020.09.27 &lt;int&gt;, ## # X2020.09.26 &lt;int&gt;, X2020.09.25 &lt;int&gt;, ## # X2020.09.24 &lt;int&gt;, X2020.09.23 &lt;int&gt;, ## # X2020.09.22 &lt;int&gt;, X2020.09.21 &lt;int&gt;, ## # X2020.09.20 &lt;int&gt;, X2020.09.19 &lt;int&gt;, ## # X2020.09.18 &lt;int&gt;, X2020.09.17 &lt;int&gt;, ## # X2020.09.16 &lt;int&gt;, X2020.09.15 &lt;int&gt;, ## # X2020.09.14 &lt;int&gt;, X2020.09.13 &lt;int&gt;, ## # X2020.09.12 &lt;int&gt;, X2020.09.11 &lt;int&gt;, ## # X2020.09.10 &lt;int&gt;, X2020.09.09 &lt;int&gt;, ## # X2020.09.08 &lt;int&gt;, X2020.09.07 &lt;int&gt;, ## # X2020.09.06 &lt;int&gt;, X2020.09.05 &lt;int&gt;, ## # X2020.09.04 &lt;int&gt;, X2020.09.03 &lt;int&gt;, ## # X2020.09.02 &lt;int&gt;, X2020.09.01 &lt;int&gt;, ## # X2020.08.31 &lt;int&gt;, … It is sometimes useful to rearrange the result of a query to inspect the values. For instance, we can sort on X2020.12.11 to put the group with the largest cumulative infected count first: I.state &lt;- I.county %&gt;% group_by(State) %&gt;% summarize_if(is.numeric, ~ sum(.x, na.rm = TRUE)) %&gt;% arrange(desc(X2020.12.11)) head(I.state, 2) ## # A tibble: 2 x 327 ## State ID X2020.12.11 X2020.12.10 X2020.12.09 ## &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Cali… 3.51e5 1516215 1482551 1448987 ## 2 Texas 1.23e7 1388909 1374143 1359740 ## # … with 322 more variables: X2020.12.08 &lt;int&gt;, ## # X2020.12.07 &lt;int&gt;, X2020.12.06 &lt;int&gt;, ## # X2020.12.05 &lt;int&gt;, X2020.12.04 &lt;int&gt;, ## # X2020.12.03 &lt;int&gt;, X2020.12.02 &lt;int&gt;, ## # X2020.12.01 &lt;int&gt;, X2020.11.30 &lt;int&gt;, ## # X2020.11.29 &lt;int&gt;, X2020.11.28 &lt;int&gt;, ## # X2020.11.27 &lt;int&gt;, X2020.11.26 &lt;int&gt;, ## # X2020.11.25 &lt;int&gt;, X2020.11.24 &lt;int&gt;, ## # X2020.11.23 &lt;int&gt;, X2020.11.22 &lt;int&gt;, ## # X2020.11.21 &lt;int&gt;, X2020.11.20 &lt;int&gt;, ## # X2020.11.19 &lt;int&gt;, X2020.11.18 &lt;int&gt;, ## # X2020.11.17 &lt;int&gt;, X2020.11.16 &lt;int&gt;, ## # X2020.11.15 &lt;int&gt;, X2020.11.14 &lt;int&gt;, ## # X2020.11.13 &lt;int&gt;, X2020.11.12 &lt;int&gt;, ## # X2020.11.11 &lt;int&gt;, X2020.11.10 &lt;int&gt;, ## # X2020.11.09 &lt;int&gt;, X2020.11.08 &lt;int&gt;, ## # X2020.11.07 &lt;int&gt;, X2020.11.06 &lt;int&gt;, ## # X2020.11.05 &lt;int&gt;, X2020.11.04 &lt;int&gt;, ## # X2020.11.03 &lt;int&gt;, X2020.11.02 &lt;int&gt;, ## # X2020.11.01 &lt;int&gt;, X2020.10.31 &lt;int&gt;, ## # X2020.10.30 &lt;int&gt;, X2020.10.29 &lt;int&gt;, ## # X2020.10.28 &lt;int&gt;, X2020.10.27 &lt;int&gt;, ## # X2020.10.26 &lt;int&gt;, X2020.10.25 &lt;int&gt;, ## # X2020.10.24 &lt;int&gt;, X2020.10.23 &lt;int&gt;, ## # X2020.10.22 &lt;int&gt;, X2020.10.21 &lt;int&gt;, ## # X2020.10.20 &lt;int&gt;, X2020.10.19 &lt;int&gt;, ## # X2020.10.18 &lt;int&gt;, X2020.10.17 &lt;int&gt;, ## # X2020.10.16 &lt;int&gt;, X2020.10.15 &lt;int&gt;, ## # X2020.10.14 &lt;int&gt;, X2020.10.13 &lt;int&gt;, ## # X2020.10.12 &lt;int&gt;, X2020.10.11 &lt;int&gt;, ## # X2020.10.10 &lt;int&gt;, X2020.10.09 &lt;int&gt;, ## # X2020.10.08 &lt;int&gt;, X2020.10.07 &lt;int&gt;, ## # X2020.10.06 &lt;int&gt;, X2020.10.05 &lt;int&gt;, ## # X2020.10.04 &lt;int&gt;, X2020.10.03 &lt;int&gt;, ## # X2020.10.02 &lt;int&gt;, X2020.10.01 &lt;int&gt;, ## # X2020.09.30 &lt;int&gt;, X2020.09.29 &lt;int&gt;, ## # X2020.09.28 &lt;int&gt;, X2020.09.27 &lt;int&gt;, ## # X2020.09.26 &lt;int&gt;, X2020.09.25 &lt;int&gt;, ## # X2020.09.24 &lt;int&gt;, X2020.09.23 &lt;int&gt;, ## # X2020.09.22 &lt;int&gt;, X2020.09.21 &lt;int&gt;, ## # X2020.09.20 &lt;int&gt;, X2020.09.19 &lt;int&gt;, ## # X2020.09.18 &lt;int&gt;, X2020.09.17 &lt;int&gt;, ## # X2020.09.16 &lt;int&gt;, X2020.09.15 &lt;int&gt;, ## # X2020.09.14 &lt;int&gt;, X2020.09.13 &lt;int&gt;, ## # X2020.09.12 &lt;int&gt;, X2020.09.11 &lt;int&gt;, ## # X2020.09.10 &lt;int&gt;, X2020.09.09 &lt;int&gt;, ## # X2020.09.08 &lt;int&gt;, X2020.09.07 &lt;int&gt;, ## # X2020.09.06 &lt;int&gt;, X2020.09.05 &lt;int&gt;, ## # X2020.09.04 &lt;int&gt;, X2020.09.03 &lt;int&gt;, ## # X2020.09.02 &lt;int&gt;, X2020.09.01 &lt;int&gt;, ## # X2020.08.31 &lt;int&gt;, … 8.7 Joins with dplyr R has a number of quick, elegant ways to join data frames by a common column. There are at least three ways: Base R’s merge() function, Join family of functions from dplyr, and Bracket syntax based on data.table. dplyr uses SQL database syntax for its join functions. For example, a left join means: Include everything on the left and all rows that match from the right data frame. If the join columns have the same name, all you need is left_join(x, y). If they don’t have the same name, you need a by argument, such as left_join(x, y, by = c(\"df1ColName\" = \"df2ColName\")). See an illustration in Figure 8.2. Figure 8.2: An illustration of left join and right join. Different join functions control what happens to rows that exist in one table but not the other. left_join keeps all the entries that are present in the left (first) table and excludes any that are only in the right table. right_join keeps all the entries that are present in the right table and excludes any that are only in the left table. inner_join keeps only the entries that are present in both tables. inner_join is the only function that guarantees you won’t generate any missing entries. full_join keeps all of the entries in both tables, regardless of whether or not they appear in the other table. Figure 8.3: An illustration of inner join and full join. The join functions are nicely illustrated in RStudio’s [Data wrangling cheatsheet][https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf]. {r join, out.width = \"80%\", echo=FALSE, fig.align = \"center\", fig.cap=\"An illustration of the join functions in RStudio’s Data wrangling cheatsheet.\"} knitr::include_graphics(\"figures/dplyr-joins.png\") Toy examples with joins set.seed(12345) x &lt;- data.frame(key= LETTERS[c(1:3, 5)], value1 = sample(1:10, 4), stringsAsFactors = FALSE) y &lt;- data.frame(key= LETTERS[c(1:4)], value2 = sample(1:10, 4), stringsAsFactors = FALSE) x ## key value1 ## 1 A 3 ## 2 B 8 ## 3 C 2 ## 4 E 5 y ## key value2 ## 1 A 8 ## 2 B 2 ## 3 C 6 ## 4 D 3 # What&#39;s in both x and y? inner_join(x, y, by = &quot;key&quot;) ## key value1 value2 ## 1 A 3 8 ## 2 B 8 2 ## 3 C 2 6 # What&#39;s in X and bring with it the stuff that matches in Y left_join(x, y, by = &quot;key&quot;) ## key value1 value2 ## 1 A 3 8 ## 2 B 8 2 ## 3 C 2 6 ## 4 E 5 NA # What&#39;s in Y and bring with it the stuff that matches in Y right_join(x, y, by = &quot;key&quot;) ## key value1 value2 ## 1 A 3 8 ## 2 B 8 2 ## 3 C 2 6 ## 4 D NA 3 # Give me everything! full_join(x, y, by = &quot;key&quot;) ## key value1 value2 ## 1 A 3 8 ## 2 B 8 2 ## 3 C 2 6 ## 4 E 5 NA ## 5 D NA 3 # Give me the stuff in X that is not in Y anti_join(x, y, by = &quot;key&quot;) ## key value1 ## 1 E 5 # Want everything that doesn&#39;t match? full_join(anti_join(x, y, by = &quot;key&quot;), anti_join(y, x, by = &quot;key&quot;), by= &quot;key&quot;) ## key value1 value2 ## 1 E 5 NA ## 2 D NA 3 Practice with joins for real data We first get the data named pop.county from the github R package slid. Note that there are four variables in this data: ID, County, State, population. library(slid) data(I.county) dim(I.county) ## [1] 3104 328 data(pop.county) dim(pop.county) ## [1] 3142 4 Now, we would like to join the two tables: I.county and pop.county using the left_join as follows: I.county.w.pop &lt;- left_join(I.county, pop.county, by = &quot;ID&quot;) %&gt;% dplyr::select(-c(&quot;County.y&quot;, &quot;State.y&quot;)) or we can: I.county.w.pop &lt;- left_join(I.county, dplyr::select(pop.county, c(ID,population)), by = &quot;ID&quot;) 8.8 Reshaping Data - Change the layout of a data set Sometimes, we want to convert data from a wide format to a long format. Many functions in R expect data to be in a long format rather than a wide format. Programs like SPSS, however, often use wide-formatted data. There are two sets of methods that are explained below: gather() and spread() from the tidyr package. This is a newer interface to the reshape2 package. melt() and dcast() from the reshape2 package. Many other methods aren’t covered here since they are not as easy to use. 8.8.1 From wide to long Below we would like to change the data I.state from wide format to long format. library(slid) data(I.state) names(I.state) Use gather(data, key, value, …) data = the dataframe you want to morph from wide to long key = the name of the new column that is levels of what is represented in the wide format as many columns value = the name of the column that will contain the values … = columns to gather, or leave (use -column to gather all except that one) The gather functions are nicely illustrated in RStudio’s [Data wrangling cheatsheet][https://rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf] as shown in Figure 8.4. Figure 8.4: An illustration of gather function. I.state.wide &lt;- I.state %&gt;% dplyr::select(State,X2020.12.11:X2020.01.22) dim(I.state.wide) ## [1] 49 326 I.state.long &lt;- gather(I.state.wide, DATE, Death, X2020.12.11:X2020.01.22, factor_key = TRUE) %&gt;% arrange(State) dim(I.state.long) ## [1] 15925 3 Use pivot_longer() The function pivot_longer() is an updated approach to gather(), designed to be both simpler to use and to handle more use cases. It is recommended to use pivot_longer() for new code; gather() isn’t going away but is no longer under active development. I.state.wide &lt;- I.state %&gt;% dplyr::select(State,X2020.12.11:X2020.01.22) dim(I.state.wide) ## [1] 49 326 I.state.long &lt;- I.state.wide %&gt;% pivot_longer(X2020.12.11:X2020.01.22, names_to = &quot;DATE&quot;, values_to = &quot;Death&quot;) See more complicated examples from the introduction of ‘tidyr’ package. 8.8.2 From long to wide Now let’s change the data back to the wide format, and we can use spread. Use Use spread(data, key, value) data = the dataframe you want to morph from long to wide key = the name of the column that contains the key value = the name of the column contains the values The spread functions are nicely illustrated in RStudio’s [Data wrangling cheatsheet][https://rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf] as shown in Figure 8.5. Figure 8.5: An illustration of spread function. I.state.wide &lt;- spread(I.state.long, DATE, Death) dim(I.state.wide) ## [1] 49 326 Use pivot_wider() We can also use the function pivot_wider(), which “widens” data, increasing the number of columns and decreasing the number of rows. The inverse transformation is pivot_longer(). I.state.wide &lt;- I.state.long %&gt;% pivot_wider(names_from = DATE, values_from = Death) dim(I.state.wide) ## [1] 49 326 See more complicated examples from the introduction of ‘tidyr’ package. 8.9 Exercises We are going to explore the basic data manipulation verbs of dplyr using nycflights13::flights. Install the R package nycflights13. library(nycflights13) data(flights) names(flights) ## [1] &quot;year&quot; &quot;month&quot; &quot;day&quot; ## [4] &quot;dep_time&quot; &quot;sched_dep_time&quot; &quot;dep_delay&quot; ## [7] &quot;arr_time&quot; &quot;sched_arr_time&quot; &quot;arr_delay&quot; ## [10] &quot;carrier&quot; &quot;flight&quot; &quot;tailnum&quot; ## [13] &quot;origin&quot; &quot;dest&quot; &quot;air_time&quot; ## [16] &quot;distance&quot; &quot;hour&quot; &quot;minute&quot; ## [19] &quot;time_hour&quot; Next, use ?flights to see more detailed information about this dataset. Select dep_time, dep_delay, arr_time, and arr_delay from flights. Find all flights on January 1st. Find all flights that departed in December. Find all flights that flew to Houston. Find all flights that were operated by United, American, or Delta. Sort flights to find the most delayed flights. Find the flights that left earliest. What does the following code provide? delays &lt;- flights %&gt;% group_by(dest) %&gt;% summarise( count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE) ) What does the following code provide? by_day &lt;- group_by(flights, year, month, day) summarize(by_day, delay = mean(dep_delay, na.rm = TRUE)) "],
["advanced-programming-in-r.html", "Chapter 9 Advanced Programming in R 9.1 Grouped expressions 9.2 Conditional execution: if statements 9.3 Writing Functions 9.4 Lexical vs. Dynamic Scoping 9.5 Exercises", " Chapter 9 Advanced Programming in R Now that you have learned the elementary commands in R and many ways of applying them, it is time to discover its advanced functionalities. This chapter introduces grouped expressions, conditional execution, loops, and deals more intensively with writing functions. 9.1 Grouped expressions R is an expression language in the sense that its only command type is a function or expression which returns a result. Even an assignment is an expression whose result is the value assigned, and it may be used wherever any expression may be used; in particular multiple assignments are possible. Commands may be grouped together in braces, {expr1 ; expr2 ;...; exprm} in which case the value of the group is the result of the last expression in the group evaluated. Since such a group is also an expression it may, for example, be itself included in parentheses and used a part of an even larger expression, and so on. 9.2 Conditional execution: if statements The language has available a conditional construction of the form if (expr_1) expr_2 else expr_3 where expr_1 must evaluate to a single logical value and the result of the entire expression is then evident. Here is an example of an if statement: if (x &lt; 3) print(&quot;x less than 3&quot;) else print (&quot;x not less than 3&quot;) The “short-circuit” operators &amp;&amp; and || are often used as part of the condition in an if statement. Whereas &amp; and | apply element-wise to vectors, &amp;&amp; and || apply to vectors of length one, and only evaluate their second argument if necessary. If you want statement 1 and / or statement 2 to consist of more than one statement, then the if construct looks like this: if (condition) { statement 1a statement 1b statement 1c } else { statement 2a statement 2b statement 2c } The group of statements between a “{” and a “}” are treated as one statement by the if and else. There is a vectorized version of the if/else construct, the ifelse() function. This has the form ifelse(condition, a, b) and returns a vector of the length of its longest argument, with elements a[i] if condition[i] is true, otherwise b[i]. 9.2.1 Iterations An iteration is, in principle, a loop or repeatedly executed instruction cycle, with only a few changes in each cycle. In programming languages that are not matrix or array-oriented, like C, Fortran, even a simple matrix multiplication needs three nested loops (over rows, columns, and the indices). Since R is matrix-oriented, these operations are much more efficient and easy to formulate in mathematical terms. This means they are faster than loops and the code is much easier to read and write. Note: whenever possible, try to avoid loops. 99% of the time, an operation on matrices is much more elegant as well as much faster. Try to use vectorized statements, or functions like apply or tapply. Here is an example, calculated on an IBM PC. If we define a vector x with 50,000 elements, and assign the square of x to y, without using a loop, the following two lines take about 2 seconds to execute. x &lt;- 1:100000 y &lt;- x^2 On the other hand, using an explicit loop statement (for) over the values of x and y, respectively, results in the code # Initialization x &lt;- y &lt;- 1:100000 for (i in 1:100000) y[i] &lt;- x[i]^2 and does exactly the same as the two lines above. You can see that the first expressions are easier to read and on top of that, the second little program needs about 2 minutes to execute, or about 60 times longer than the first program. We will treat the different forms of loops, for and while, in more detail in the following. The for loop The for statement loops over all elements in a list or vector: for (variable in sequence) {R commends} Try these examples at the R prompt. for (i in 1:3) print(i) fnord &lt;- list(&quot;Cheese&quot;, TRUE, 27.5) for (i in fnord) print(i) Note the colon (“:”) operator generates a sequence of integers. You can use this in places other than the for loop or array indexing, too. The while loop If you need a loop for which you don’t know in advance how many iterations there will be, you can use the “while” statement. It works like this: while(condition){R commends} You can construct condition in the same way as for an if statement. A simple while loop Calculate the sum over 1, 2, 3, …, until the sum is larger than 1000. n &lt;-0 # the iteration counter sum.so.far &lt;- 0 # store the added values while (sum.so.far &lt;= 1000){ n &lt;- n + 1 sum.so.far &lt;- sum.so.far + n } sum.so.far ## [1] 1035 n ## [1] 45 9.3 Writing Functions 9.3.1 Simple examples Our examples so far have been too short to break up into sub-programs. However, any sizeable R project will be easier to deal with if each specific task is put into its own sub-program or function, which your main program can call. Functions are used to logically break our code into simpler parts which become easy to maintain and understand. The function definition syntax of R is similar to that of JavaScript. For example: fsum &lt;- function(a, b) { return (a + b) } Your first R function It’s pretty straightforward to create your own function in R programming. mean &lt;- function(x) { return(sum(x) / length(x)) } mean(1:15) ## [1] 8 mean(c(1:15, NA)) ## [1] NA mean &lt;- function(x, na.rm=F) { if (na.rm) x &lt;- na.omit(x) return(sum(x) / length(x)) } ! mean(1:15) ## [1] FALSE mean(c(1:15, NA), na.rm = T) ## [1] 8 Function mean: Name: mean Input arguments x, na.rm = T names, default values Body if(na.rm) x &lt;- na.omit(x) Output values return(sum(x)/length(x)) Another Example: Consider a function to calculate the two sample t-statistic, showing “all the steps”. This is an artificial example, of course, since there are other, simpler ways of achieving the same end. The function is defined as follows: twosam &lt;- function(y1, y2) { n1 &lt;- length(y1); n2 &lt;- length(y2) yb1 &lt;- mean(y1); yb2 &lt;- mean(y2) s1 &lt;- var(y1); s2 &lt;- var(y2) s &lt;- ((n1 - 1)*s1 + (n2 - 1) * s2)/(n1 + n2 - 2) tst &lt;- (yb1 - yb2)/sqrt(s * (1/n1 + 1/n2)) tst } With this function defined, you could perform two sample t-tests using a call such as tstat &lt;- twosam(data$male, data$female); tstat The more general syntax of a function declaration is as follows: Function-name &lt;- function(arguments){ function body return (output arguments) } Note 1: Instead of using return at the end, you can also simply put a variable’s name as the last expression. R returns the output of the last expression in the function, but return is the more proper way of returning values. Using this practice assures that the return argument is indeed the one wanted. In this fashion, a declaration like f &lt;- function (x) x^2 is valid, but not as proper as using return (x^2). Note 2: Other Control utilities for functions warning and stop Stop To stop the action of a function and print an error message, one can use the stop() function. Warning To print a warning message in unexpected situations without aborting the evaluation flow of a function, one can use the function warning(\"...\"). myfct &lt;- function(x1) { if (x1 &gt;= 0) print(x1) else stop(&quot;This function did not finish, because x1 &lt; 0&quot;) warning(&quot;Value needs to be &gt; 0&quot;) } myfct(x1 = 2) myfct(x1 = -2) 9.3.2 Named arguments and defaults As first noted in the previous chapters, if arguments to called functions are given in the name=object form, they may be given in any order. Furthermore, the argument sequence may begin in the unnamed, positional form, and specify named arguments after the positional arguments. Thus if there is a function fun1 defined by fun1 &lt;- function(data,data.frame,graph,limit) [function body omitted] Then the function may be invoked in several ways, for example ans &lt;- fun1(d, df, 20, T) ans &lt;- fun1(d, df, graph=T, limit = 20) ans &lt;- fun1(data = d, limit = 20, graph = T, data.frame = df) are all equivalent. In many cases arguments can be given commonly appropriate default values, in which case they may be omitted altogether from the call when the defaults are appropriate. For example, if fun1 were defined as fun1 &lt;- function(data, data.frame, graph = T, limit = 20) it could be called as ans &lt;- fun1(d, df) which is now equivalent to the three cases above, or as ans &lt;- fun1(d, df, limit = 10) which changes one of the defaults. 9.4 Lexical vs. Dynamic Scoping 9.4.1 Scoping rules The scoping rules of a language determine how a value is associated with a free variable in a function. R uses lexical scoping or static scoping. An alternative to lexical scoping is dynamic scoping, which is implemented by some languages. Lexical scoping turns out to be particularly useful for simplifying statistical computations. Related to the scoping rules is how R uses the search list to bind a value to a symbol. Consider the following function. f &lt;- function(x, y){ x ^ 2 + y / z } This function has two formal arguments x and y. In the body of the function there is another symbol z. In this case z is called a free variable. The scoping rules of a language determine how values are assigned to free variables. Free variables are not formal arguments and are not local variables (assigned insided the function body). Lexical scoping in R means that the values of free variables are searched for in the environment in which the function was defined. 9.4.2 An Environment An environment is a collection of (symbol, value) pairs, i.e. x is a symbol and 3.14 might be its value. Every environment has a parent environment and it is possible for an environment to have multiple “children”. The only environment without a parent is the empty environment. A function, together with an environment, makes up what is called a closure or function closure. Most of the time we don’t need to think too much about a function and its associated environment (making up the closure), but occasionally, this setup can be very useful. The function closure model can be used to create functions that “carry around” data with them. How do we associate a value to a free variable? There is a search process that occurs that goes as follows: If the value of a symbol is not found in the environment in which a function was defined, then the search is continued in the parent environment. The search continues down the sequence of parent environments until we hit the top-level environment; this usually the global environment (workspace) or the namespace of a package. After the top-level environment, the search continues down the search list until we hit the empty environment. If a value for a given symbol cannot be found once the empty environment is arrived at, then an error is thrown. We can use the following example to demonstrate the difference between lexical and dynamic scoping rules. y &lt;- 10 f &lt;- function(x) { y &lt;- 2 y^2 + g(x) } g &lt;- function(x) { x * y } What is the value of the following expression? f(3) With lexical scoping the value of y in the function g is looked up in the environment in which the function was defined, in this case the global environment, so the value of y is 10. With dynamic scoping, the value of y is looked up in the environment from which the function was called (sometimes referred to as the calling environment). In R the calling environment is known as the parent frame. In this case, the value of y would be 2. When a function is defined in the global environment and is subsequently called from the global environment, then the defining environment and the calling environment are the same. This can sometimes give the appearance of dynamic scoping. Consider this example. g &lt;- function(x) { a &lt;- 3 x + a + y # &#39;y&#39; is a free variable } g(2) ## [1] 15 y &lt;- 3 g(2) ## [1] 8 Here, y is defined in the global environment, which also happens to be where the function g() is defined. 9.5 Exercises Write functions Fun1 and Fun2 such that if xVec is the vector (x_1,x_2,...,x_n), then Fun1(xVec) returns the vector \\((x_1,x_2^2,...,x_n^n)\\) and Fun2(xVec) returns \\((x_1,x_2^2/2,...,x_n^n/n)\\). Write a function which takes a single argument which is a matrix. The function should return a matrix which is the same as the function argument but every odd number is doubled. For example, the result of using the function on the matrix \\[ \\begin{bmatrix} 1&amp;1&amp;3\\\\2&amp;4&amp;6\\\\-2&amp;-1&amp;-3\\end{bmatrix} \\] should be \\[ \\begin{bmatrix} 2&amp;2&amp;6\\\\10&amp;2&amp;6\\\\-2&amp;-2&amp;-6\\end{bmatrix} \\] Write a function Fun3, which takes two arguments x and n, and x is a single number and n is a strictly positive integer. The function returns the value of \\((1+x^2/2+ ...+x^n/n)\\), report the value when x=2 and n=10. What does the following code return? Run the following code in your head, then confirm the output by running the R code. x &lt;- 10 f1 &lt;- function(x) { function() { x + 10 } } f1(1)() What does the following code return? Run the following code in your head, then confirm the output by running the R code. x &lt;- 1 h1 &lt;- function() { y &lt;- 2 i1 &lt;- function() { z &lt;- 3 c(x, y, z) } i1() } h1() What does the following code return? Run the following code in your head, then confirm the output by running the R code. f &lt;- function(x) { f &lt;- function(x) { f &lt;- function(x) { x^2 } f(x) + 1 } f(x) * 2 } f(10) What does the following code return? Run the following code in your head, then confirm the output by running the R code. x &lt;- 2 g1 &lt;- function() { y &lt;- 1 c(x, y) } g1() "],
["simulations.html", "Chapter 10 Simulations 10.1 Probability Distributions and Generating Random Variables 10.2 More Examples 10.3 Setting Random Number Seed 10.4 Example: Normal Approximation to the Binomials 10.5 Random Sampling using sample 10.6 A Simulation Example 10.7 Basics of Simulation 10.8 Exercises", " Chapter 10 Simulations Simulation is an important (and big) topic for both statistics and for a variety of other areas where there is a need to introduce randomness. Sometimes you want to implement a statistical procedure that requires random number generation or sampling (i.e. Markov chain Monte Carlo, the bootstrap, random forests, bagging) and sometimes you want to simulate a system and random number generators can be used to model random inputs. R comes with a set of pseuodo-random number generators that allow you to simulate from well-known probability distributions like the Normal, Poisson, and binomial. Some example functions for probability distributions in R. 10.1 Probability Distributions and Generating Random Variables One convenient use of R is to provide a comprehensive set of statistical tables. Functions are provided to evaluate the cumulative distribution function \\(P(X \\leq x)\\), the probability density function and the quantile function (given q, the smallest x such that \\(P(X \\leq x) &gt; q\\)), and to simulate from the distribution. R provides four types of functions for dealing with distributions. Each type begins with a letter designating its purpose, followed by a name specifying the distribution. p - probability (argument is deviate, returns probability) d - density (argument is deviate, returns density value) q - quantile function (argument is probability - returns deviate) r - random numbers (argument is n, returns vector of random numbers) Popular Distributions Figure 10.1 shows some popular distributions that we might use them often. Figure 10.1: Popular distributions. Prefix the name given here by ‘d’ for the density, ‘p’ for the CDF, ‘q’ for the quantile function and ‘r’ for simulation (random deviates). The first argument is x for dxxx, q for pxxx, p for qxxx and n for rxxx (except for rhyper and rwilcox, for which it is nn, for example, rwilcox(nn,m,n)). In not quite all cases is the non-centrality parameter ncp are currently available: see the on-line help for details. In not quite all cases is the non-centrality parameter ncp are currently available: see the on-line help for details. # 2-tailed p-value for t distribution 2 * pt(-2.43, df = 13) ## [1] 0.0303309 # upper 1% point for an F(2, 7) distribution qf(0.01, 2, 7, lower.tail = FALSE) ## [1] 9.546578 10.2 More Examples The following are some simple examples. Uniform Uniform numbers are ones that are “equally likely” to be in the specified range. Often these numbers are in [0, 1] for computers, but in practice can be between [a, b] where a, b depend upon the problem. An example might be the time you wait at a traffic light. This might be uniform on [0, 2]. runif(1, 0, 2) # time at light ## [1] 0.7824067 runif(5, 0, 2) # time at 5 lights ## [1] 0.9249893 0.7762880 0.8049703 0.3579272 1.9033175 runif(5) # 5 random numbers in [0,1] ## [1] 0.4537281 0.3267524 0.9654153 0.7074819 0.6445426 Binomial The binomial random numbers are discrete random numbers. They have the distribution of the number of successes in n independent Bernoulli trials where a Bernoulli trial results in success or failure, success with probability p. # Compute P(X &lt;= 5) for X Binomial(8, 0.9) pbinom(5, 8, 0.9) ## [1] 0.03809179 # Compute P(45 &lt; X &lt; 55) for X Binomial(100, 0.5) pbinom(54, 100, 0.5) - pbinom(45, 100, 0.5) ## [1] 0.6317984 # Find the 0.05 quantile for X Binomial(16, 0.5) qbinom(0.05, 100, 0.5) ## [1] 42 # Generate 100 random variables from Binomial(20, 0.2) rbinom(100, 20, 0.2) ## [1] 3 5 4 3 4 5 0 2 5 3 3 6 6 4 2 5 4 7 5 3 3 1 1 1 4 7 6 ## [28] 3 3 5 4 5 2 4 3 5 3 8 5 8 3 7 2 4 7 5 4 3 3 1 4 7 5 4 ## [55] 2 6 4 0 1 2 3 6 4 5 1 7 6 2 4 5 4 5 5 2 3 3 4 8 4 4 6 ## [82] 5 6 3 3 4 3 5 3 5 6 8 4 0 3 4 4 2 5 5 Normal # Find P(Z &lt;= 1.5). pnorm(1.5) ## [1] 0.9331928 # Find the 0.05-quantile for N(0, 1) qnorm(0.05) ## [1] -1.644854 #Find the 0.05-quantile for N(1, 4) qnorm(0.05, mean = 1, sd = 2) ## [1] -2.289707 # Generate 50 random variables from N(4, 2) rnorm(50, 4, 2) ## [1] 5.6848973 2.2193532 5.5059217 4.8904319 4.8422124 ## [6] 6.2991845 2.2073596 5.7393427 5.0118233 4.6634041 ## [11] 7.4799994 3.9821491 3.3475663 4.2970864 3.2402642 ## [16] 5.5768822 3.6574869 4.5167635 4.4803464 5.7847276 ## [21] 3.9614367 2.1237451 3.4716128 2.2309502 2.9996141 ## [26] 5.3538034 6.8181437 5.9010480 3.5447031 2.7096113 ## [31] 5.7679356 7.0820644 1.9846826 6.4115762 3.0144272 ## [36] -0.9218229 5.6693115 3.7904313 6.4808597 4.0667339 ## [41] 5.4484878 1.0128678 4.7777647 5.0230307 2.7192348 ## [46] 3.6517822 4.1752274 2.0950020 1.5177391 4.1735536 The Poisson distribution is commonly used to model data that come in the form of counts. rpois(10, 1) ## Counts with a mean of 1 ## [1] 1 2 1 1 1 0 1 1 1 1 rpois(10, 2) ## Counts with a mean of 2 ## [1] 2 6 4 2 1 4 4 4 3 2 rpois(10, 20) ## Counts with a mean of 20 ## [1] 22 20 23 27 17 33 26 13 31 15 10.3 Setting Random Number Seed When simulating any random numbers it is essential to set the random number seed. Setting the random number seed with set.seed() ensures reproducibility of the sequence of random numbers. For example, I can generate 5 Normal random numbers with rnorm(). set.seed(1) rnorm(5) ## [1] -0.6264538 0.1836433 -0.8356286 1.5952808 0.3295078 Note that if I call rnorm() again I will of course get a different set of 5 random numbers. rnorm(5) ## [1] -0.8204684 0.4874291 0.7383247 0.5757814 -0.3053884 If I want to reproduce the original set of random numbers, I can just reset the seed with set.seed(). set.seed(1) rnorm(5) ## Same as before ## [1] -0.6264538 0.1836433 -0.8356286 1.5952808 0.3295078 In general, you should always set the random number seed when conducting a simulation! Otherwise, you will not be able to reconstruct the exact numbers that you produced in an analysis. 10.4 Example: Normal Approximation to the Binomials In our introductory level statistics, we know that we can use normal to approximate binomials. For example, X ~ BINOM(100, 0.4), let us use the binomial functions and normal approximations in R to compute \\(P(35 &lt; X \\leq 45)\\). We first use the binomial functions in R to compute \\(P(35 &lt; X \\leq 45)\\) pbinom(45, 100, .4) - pbinom(35, 100, .4) ## [1] 0.6894402 Now according to the normal approximation and the continuity correction, we can use the normal functions in R to compute P(35.5 &lt; X ≤ 45.5): mu &lt;- 100 * .4 sig &lt;- sqrt(100 * .4 * (1 - .4)) pnorm(45.5, mu, sig) - pnorm(35.5, mu, sig) ## [1] 0.6900506 10.5 Random Sampling using sample R has the ability to sample with and without replacement. That is, choose at random from a collection of things such as the numbers 1 through 6 in the dice rolling example. The sampling can be done with replacement (like dice rolling) or without replacement (like a lottery). By default sample samples without replacement each object having equal chance of being picked. You need to specify replace=TRUE if you want to sample with replacement. Furthermore, you can specify separate probabilities for each if desired. The sample() function draws randomly from a specified set of (scalar) objects allowing you to sample from arbitrary distributions of numbers. Here are some examples: # Roll a die sample(1:6, 10, replace = TRUE) ## [1] 3 3 1 5 5 2 6 6 2 1 ## toss a coin sample(c(&quot;H&quot;, &quot;T&quot;), 10, replace = TRUE) ## [1] &quot;H&quot; &quot;H&quot; &quot;H&quot; &quot;H&quot; &quot;H&quot; &quot;T&quot; &quot;H&quot; &quot;H&quot; &quot;T&quot; &quot;T&quot; ## pick 6 of 54 (a lottery) sample(1:54, 6) # no replacement ## [1] 25 44 15 33 20 35 ## pick a card. (Fancy! Uses paste, rep) cards &lt;- paste(rep(c(&quot;A&quot;, 2:10, &quot;J&quot;, &quot;Q&quot;, &quot;K&quot;), 4), c(&quot;H&quot;, &quot;D&quot;, &quot;S&quot;, &quot;C&quot;)) # a pair of jacks, no replacement sample(cards, 5) ## [1] &quot;6 D&quot; &quot;10 D&quot; &quot;3 D&quot; &quot;Q D&quot; &quot;8 S&quot; 10.6 A Simulation Example Toss a single die 1000 times, each time note down the number that showed up. Find the distribution of the 1000 observations # distributions of a single six sided die # generate a uniform random distribution from min to max numcases &lt;- 1000 #how many cases to generate min &lt;- 1 #set parameters max &lt;- 6 # generate random uniform numcases numbers from min to max x &lt;- sample(1:6, numcases, replace = TRUE) # show the histogram hist(x,prob = T, xlim = range(min - .5, max + .5), main = paste(numcases,&quot; roles of a single die&quot;), breaks = seq(min - .5, max + .5, 1)) Figure 10.2: A histogram based on 1000 roles of a single die. Toss two dice 1000 times, each time note down the number that showed up and compute the average of the two dice. Find the distribution of the 1000 sample means # generate a uniform random distribution from min to max # for numcases sample size 2 numcases &lt;- 1000 #how many cases to generate min &lt;- 1 #set parameters max &lt;- 6 x1 &lt;- sample(1:6, numcases, replace=TRUE) x2 &lt;- sample(1:6, numcases, replace=TRUE) x.bar &lt;- (x1 + x2) / 2 hist(x.bar, prob = T, xlim = range(min - .5, max + .5), main = paste(numcases, &quot; roles of a pair of dice&quot;)) Figure 10.3: A histogram based on 1000 roles of a pair of dice. Toss k dice 1000 times, each time note down the number that showed up and compute the average of the k dice. Find the distribution of the 1000 sample means # Toss k=100 dice k &lt;- 100 numcases &lt;- 1000 #how many samples to take? min &lt;- 1 #lowest value max &lt;- 6 sum &lt;- rep(0,numcases) for(i in 1:k){ dice &lt;- sample(1:6, numcases, replace=TRUE) sum &lt;- sum + dice } x.bar &lt;- sum / k hist(x.bar, prob = T, xlim = range(min - .5, max + .5), main = paste( numcases,&quot; roles of 100 dice&quot;)) Figure 10.4: A histogram based on 1000 roles of 100 dice. 10.7 Basics of Simulation We have seen that we can use runif (uniform), rpois (poisson), rnorm (normal), rbinom (binomial), rgamma (gamma), rbeta (beta), …, to generate random numbers from known distribution. First argument for all is n, number of samples to generate. Then, parameters of the distribution (always check that the distribution is parameterised the way you expect). In this section, we focus on repeating the simulation multiple times. 10.7.1 Repetition Use the replicate function replicate(n, expression) Find the mean of 100 random standard normal numbers, and repeat it 10 times replicate(10, mean(rnorm(100))) ## [1] -0.080971362 -0.087927875 0.215721843 -0.151144052 ## [5] 0.064324835 -0.065627610 0.228410840 -0.006319742 ## [9] -0.032525699 -0.101028481 Find the mean of 10 random standard normal numbers, repeat it 100 times, and draw the histgram of 100 means hist(replicate(100, mean(rnorm(10)))) Figure 10.5: Histogram of the mean of 10 random standard normal numbers based on 100 replications. Simulation – The Central Limit Theorem In our introductory level statistics, we also learned the central limit theorem (CLT): if \\(X_i\\) are drawn independently from a population where \\(\\mu\\) and \\(\\sigma\\) are known, then \\[ \\frac{\\bar{X}-\\mu}{\\sigma/\\sqrt{n}} \\] is asymptotically normal with mean 0 and variance 1. That is, if \\(n\\) is large enough the average is approximately normal with mean \\(\\mu\\) and standard deviation \\(\\sigma/\\sqrt{n}\\). How can we check this? Simulation is an excellent way. Let’s investigate. Suppose we start with a skewed distribution, the CLT says that the average will eventually look normal. That is, it is approximately normal for large \\(n\\). What does “eventually” mean? What does “large” mean? An example of a skewed distribution is the exponential. Note that the exponential distribution has standard deviation equal to its mean, so we only need to specify the mean. To generate a function of exponential distribution with mean 10 (standard deviation is also 10 then) rexp(n, 1 / 10) Here is a function to create a single standardized average based on \\(n=5\\) exponential random variables with mean 10: f &lt;- function(n = 5, mu = 10) { (mean(rexp(n, 1 / mu)) - mu) / (mu/sqrt(n)) } But that is only one of these random numbers. We really want lots of them to see their distribution. How can we create 100 of them? We can use for loops. results &lt;- replicate(100, f(5, 10)) We can view the results with a histogram: xvals &lt;- seq(-3, 3, .01) # for the density plot hist(results, probability = TRUE, main = &quot;n=5&quot;, col = gray(.95)) # plot normal curve points(xvals, dnorm(xvals, 0, 1), type=&quot;l&quot;) Figure 10.6: Histogram of the mean of 5 random exponential variables with mean 10 based on 100 replications. Repeat the above for \\(n=15,~30,~50,~100\\). The histogram becomes very bell shaped between \\(n=15\\) and \\(n=50\\), although even at \\(n=50\\) it appears to still be a little skewed. Let us put the above together. # create a single standardized average based on n exponential # random variables with mean mu: par(mfrow = c(1,2)) f = function(n, mu) { (mean(rexp(n, 1 / mu)) - mu) / (mu / sqrt(n)) } # sample size n=5, mu=10, repeat 100 times xvals &lt;- seq(-3, 3, .01) # for the density plot hist(replicate(100, f(5, 10)), probability = TRUE, main = &quot;n=5&quot;, col = gray(.95)) # plot normal curve points(xvals, dnorm(xvals, 0, 1), type = &quot;l&quot;) # sample size n=50, repeat 100 times xvals = seq(-3, 3, .01) # for the density plot hist(replicate(100, f(50, 10)), probability = TRUE, main = &quot;n=50&quot;, col = gray(.95)) # plot normal curve points(xvals,dnorm(xvals, 0, 1), type = &quot;l&quot;) Figure 10.7: Histogram of the mean of 5 (left) or 50 (right) random exponential variables with mean 10 based on 100 replications. You can also build up a function to achieve the above simulation goals. sim1 = function(n){ hist(replicate(n, mean(rnorm(100)))) } sim2 = function(n, m){ hist(replicate(n, mean(rnorm(m)))) } sim3 = function(n, m, d){ if(d==&quot;gaussian&quot;){ hist(replicate(n, mean(rnorm(m)))) } if(d==&quot;uniform&quot;){ hist(replicate(n, mean(runif(m)))) } } 10.8 Exercises Generate 10 random numbers from a uniform\\((0,10)\\). Use R to find the maximum and minimum values. Generate 10 random normal numbers with mean 5 and standard deviation 5 (\\(N(5,5^2)\\)). How many are less than 0? (Use R) Select 6 numbers from a lottery containing 49 balls. What is the largest number? What is the smallest? [Hint: sample(1:49,6)] Answer these using R. For normal\\((0,1)\\), find a number \\(z^{\\ast}\\) solving \\(P (Z &lt; z^{\\ast}) = 0.05\\) (use qnorm). For normal\\((0,1)\\), find a number \\(z^{\\ast}\\) solving \\(P (-z^{\\ast}&lt; Z&lt; z^{\\ast}) = 0.05\\) (use qnorm and symmetry). How much area (probability) is to the right of 1.5 for a \\(N(0,2^2)\\)? Toss a fair coin 50 times (using R). How many heads do you have? Generate the data from normal distribution: one dataset with \\(n =100\\), mean = 10 and standard deviation = 10, the other dataset with \\(n =100\\), mean = 100 and standard deviation = 100. Make the histograms for the two datasets and compare the two distributions. How are they different? How are they similar? Are both approximately normal? "]
]
